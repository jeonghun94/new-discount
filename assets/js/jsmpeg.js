/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/client/js/jsmpeg.min.js":
/*!*************************************!*\
  !*** ./src/client/js/jsmpeg.min.js ***!
  \*************************************/
/***/ (() => {

eval("(function (window) {\n  'use strict';\n\n  var jsmpeg = window.jsmpeg = function (url, opts) {\n    opts = opts || {};\n    this.benchmark = !!opts.benchmark;\n    this.canvas = opts.canvas || document.createElement('canvas');\n    this.autoplay = !!opts.autoplay;\n    this.wantsToPlay = this.autoplay;\n    this.loop = !!opts.loop;\n    this.seekable = !!opts.seekable;\n    this.externalLoadCallback = opts.onload || null;\n    this.externalDecodeCallback = opts.ondecodeframe || null;\n    this.externalFinishedCallback = opts.onfinished || null;\n    this.progressive = !!opts.progressive;\n    this.progressiveThrottled = !!opts.progressiveThrottled;\n    this.progressiveChunkSize = opts.progressiveChunkSize || 256 * 1024;\n    this.progressiveChunkSizeMax = 4 * 1024 * 1024;\n    this.customIntraQuantMatrix = new Uint8Array(64);\n    this.customNonIntraQuantMatrix = new Uint8Array(64);\n    this.blockData = new Int32Array(64);\n    this.zeroBlockData = new Int32Array(64);\n    this.fillArray(this.zeroBlockData, 0); // Use WebGL for YCbCrToRGBA conversion if possible (much faster)\n\n    if (!opts.forceCanvas2D && this.initWebGL()) {\n      this.renderFrame = this.renderFrameGL;\n      this.updateLoader = this.updateLoaderGL;\n    } else {\n      this.canvasContext = this.canvas.getContext('2d');\n      this.renderFrame = this.renderFrame2D;\n      this.updateLoader = this.updateLoader2D;\n    }\n\n    if (url instanceof WebSocket) {\n      this.client = url;\n      this.client.onopen = this.initSocketClient.bind(this);\n    } else if (this.progressive) {\n      this.beginProgressiveLoad(url);\n    } else {\n      this.load(url);\n    }\n  }; // ----------------------------------------------------------------------------\n  // Streaming over WebSockets\n\n\n  jsmpeg.prototype.waitForIntraFrame = true;\n  jsmpeg.prototype.socketBufferSize = 512 * 1024; // 512kb each\n\n  jsmpeg.prototype.initSocketClient = function () {\n    this.buffer = new BitReader(new ArrayBuffer(this.socketBufferSize));\n    this.nextPictureBuffer = new BitReader(new ArrayBuffer(this.socketBufferSize));\n    this.nextPictureBuffer.writePos = 0;\n    this.nextPictureBuffer.chunkBegin = 0;\n    this.nextPictureBuffer.lastWriteBeforeWrap = 0;\n    this.client.binaryType = 'arraybuffer';\n    this.client.onmessage = this.receiveSocketMessage.bind(this);\n  };\n\n  jsmpeg.prototype.decodeSocketHeader = function (data) {\n    // Custom header sent to all newly connected clients when streaming\n    // over websockets:\n    // struct { char magic[4] = 'jsmp'; unsigned short width, height; };\n    if (data[0] === SOCKET_MAGIC_BYTES.charCodeAt(0) && data[1] === SOCKET_MAGIC_BYTES.charCodeAt(1) && data[2] === SOCKET_MAGIC_BYTES.charCodeAt(2) && data[3] === SOCKET_MAGIC_BYTES.charCodeAt(3)) {\n      this.width = data[4] * 256 + data[5];\n      this.height = data[6] * 256 + data[7];\n      this.initBuffers();\n    }\n  };\n\n  jsmpeg.prototype.receiveSocketMessage = function (event) {\n    var messageData = new Uint8Array(event.data);\n\n    if (!this.sequenceStarted) {\n      this.decodeSocketHeader(messageData);\n    }\n\n    var current = this.buffer;\n    var next = this.nextPictureBuffer;\n\n    if (next.writePos + messageData.length > next.length) {\n      next.lastWriteBeforeWrap = next.writePos;\n      next.writePos = 0;\n      next.index = 0;\n    }\n\n    next.bytes.set(messageData, next.writePos);\n    next.writePos += messageData.length;\n    var startCode = 0;\n\n    while (true) {\n      startCode = next.findNextMPEGStartCode();\n\n      if (startCode === BitReader.NOT_FOUND || next.index >> 3 > next.writePos) {\n        // We reached the end with no picture found yet; move back a few bytes\n        // in case we are at the beginning of a start code and exit.\n        next.index = Math.max(next.writePos - 3, 0) << 3;\n        return;\n      } else if (startCode === START_PICTURE) {\n        break;\n      }\n    } // If we are still here, we found the next picture start code!\n    // Skip picture decoding until we find the first intra frame?\n\n\n    if (this.waitForIntraFrame) {\n      next.advance(10); // skip temporalReference\n\n      if (next.getBits(3) === PICTURE_TYPE_I) {\n        this.waitForIntraFrame = false;\n        next.chunkBegin = next.index - 13 >> 3;\n      }\n\n      return;\n    } // Last picture hasn't been decoded yet? Decode now but skip output\n    // before scheduling the next one\n\n\n    if (!this.currentPictureDecoded) {\n      this.decodePicture(DECODE_SKIP_OUTPUT);\n    } // Copy the picture chunk over to 'this.buffer' and schedule decoding.\n\n\n    var chunkEnd = next.index >> 3;\n\n    if (chunkEnd > next.chunkBegin) {\n      // Just copy the current picture chunk\n      current.bytes.set(next.bytes.subarray(next.chunkBegin, chunkEnd));\n      current.writePos = chunkEnd - next.chunkBegin;\n    } else {\n      // We wrapped the nextPictureBuffer around, so we have to copy the last part\n      // till the end, as well as from 0 to the current writePos\n      current.bytes.set(next.bytes.subarray(next.chunkBegin, next.lastWriteBeforeWrap));\n      var written = next.lastWriteBeforeWrap - next.chunkBegin;\n      current.bytes.set(next.bytes.subarray(0, chunkEnd), written);\n      current.writePos = chunkEnd + written;\n    }\n\n    current.index = 0;\n    next.chunkBegin = chunkEnd; // Decode!\n\n    this.currentPictureDecoded = false;\n    setTimeout(function () {\n      this.decodePicture();\n      this.currentPictureDecoded = true;\n    }.bind(this));\n  }; // ----------------------------------------------------------------------------\n  // Recording from WebSockets\n\n\n  jsmpeg.prototype.isRecording = false;\n  jsmpeg.prototype.recorderWaitForIntraFrame = false;\n  jsmpeg.prototype.recordedFrames = 0;\n  jsmpeg.prototype.recordedSize = 0;\n  jsmpeg.prototype.didStartRecordingCallback = null;\n  jsmpeg.prototype.recordBuffers = [];\n\n  jsmpeg.prototype.canRecord = function () {\n    return this.client && this.client.readyState === this.client.OPEN;\n  };\n\n  jsmpeg.prototype.startRecording = function (callback) {\n    if (!this.canRecord()) {\n      return;\n    } // Discard old buffers and set for recording\n\n\n    this.discardRecordBuffers();\n    this.isRecording = true;\n    this.recorderWaitForIntraFrame = true;\n    this.didStartRecordingCallback = callback || null;\n    this.recordedFrames = 0;\n    this.recordedSize = 0; // Fudge a simple Sequence Header for the MPEG file\n    // 3 bytes width & height, 12 bits each\n\n    var wh1 = this.width >> 4,\n        wh2 = (this.width & 0xf) << 4 | this.height >> 8,\n        wh3 = this.height & 0xff;\n    this.recordBuffers.push(new Uint8Array([0x00, 0x00, 0x01, 0xb3, // Sequence Start Code\n    wh1, wh2, wh3, // Width & height\n    0x13, // aspect ratio & framerate\n    0xff, 0xff, 0xe1, 0x58, // Meh. Bitrate and other boring stuff\n    0x00, 0x00, 0x01, 0xb8, 0x00, 0x08, 0x00, // GOP\n    0x00, 0x00, 0x00, 0x01, 0x00 // First Picture Start Code\n    ]));\n  };\n\n  jsmpeg.prototype.recordFrameFromCurrentBuffer = function () {\n    if (!this.isRecording) {\n      return;\n    }\n\n    if (this.recorderWaitForIntraFrame) {\n      // Not an intra frame? Exit.\n      if (this.pictureCodingType !== PICTURE_TYPE_I) {\n        return;\n      } // Start recording!\n\n\n      this.recorderWaitForIntraFrame = false;\n\n      if (this.didStartRecordingCallback) {\n        this.didStartRecordingCallback(this);\n      }\n    }\n\n    this.recordedFrames++;\n    this.recordedSize += this.buffer.writePos; // Copy the actual subrange for the current picture into a new Buffer\n\n    this.recordBuffers.push(new Uint8Array(this.buffer.bytes.subarray(0, this.buffer.writePos)));\n  };\n\n  jsmpeg.prototype.discardRecordBuffers = function () {\n    this.recordBuffers = [];\n    this.recordedFrames = 0;\n  };\n\n  jsmpeg.prototype.stopRecording = function () {\n    var blob = new Blob(this.recordBuffers, {\n      type: 'video/mpeg'\n    });\n    this.discardRecordBuffers();\n    this.isRecording = false;\n    return blob;\n  }; // ----------------------------------------------------------------------------\n  // Loading via Ajax\n\n\n  jsmpeg.prototype.intraFrames = [];\n  jsmpeg.prototype.currentFrame = -1;\n  jsmpeg.prototype.currentTime = 0;\n  jsmpeg.prototype.frameCount = 0;\n  jsmpeg.prototype.duration = 0;\n\n  jsmpeg.prototype.load = function (url) {\n    this.url = url;\n    var request = new XMLHttpRequest();\n    var that = this;\n\n    request.onreadystatechange = function () {\n      if (request.readyState == request.DONE && request.status == 200) {\n        that.loadCallback(request.response);\n      }\n    };\n\n    request.onprogress = this.updateLoader.bind(this);\n    request.open('GET', url);\n    request.responseType = \"arraybuffer\";\n    request.send();\n  };\n\n  jsmpeg.prototype.updateLoader2D = function (ev) {\n    var p = ev.loaded / ev.total,\n        w = this.canvas.width,\n        h = this.canvas.height,\n        ctx = this.canvasContext;\n    ctx.fillStyle = '#222';\n    ctx.fillRect(0, 0, w, h);\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(0, h - h * p, w, h * p);\n  };\n\n  jsmpeg.prototype.updateLoaderGL = function (ev) {\n    var gl = this.gl;\n    gl.uniform1f(gl.getUniformLocation(this.loadingProgram, 'loaded'), ev.loaded / ev.total);\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  };\n\n  jsmpeg.prototype.loadCallback = function (file) {\n    this.buffer = new BitReader(file);\n\n    if (this.seekable) {\n      this.collectIntraFrames();\n      this.buffer.index = 0;\n    }\n\n    this.findStartCode(START_SEQUENCE);\n    this.firstSequenceHeader = this.buffer.index;\n    this.decodeSequenceHeader(); // Calculate the duration. This only works if the video is seekable and we have a frame count\n\n    this.duration = this.frameCount / this.pictureRate; // Load the first frame\n\n    this.nextFrame();\n\n    if (this.autoplay) {\n      this.play();\n    }\n\n    if (this.externalLoadCallback) {\n      this.externalLoadCallback(this);\n    }\n  };\n\n  jsmpeg.prototype.collectIntraFrames = function () {\n    // Loop through the whole buffer and collect all intraFrames to build our seek index.\n    // We also keep track of total frame count here\n    var frame;\n\n    for (frame = 0; this.findStartCode(START_PICTURE) !== BitReader.NOT_FOUND; frame++) {\n      // Check if the found picture is an intra frame and remember the position\n      this.buffer.advance(10); // skip temporalReference\n\n      if (this.buffer.getBits(3) === PICTURE_TYPE_I) {\n        // Remember index 13 bits back, before temporalReference and picture type\n        this.intraFrames.push({\n          frame: frame,\n          index: this.buffer.index - 13\n        });\n      }\n    }\n\n    this.frameCount = frame;\n  };\n\n  jsmpeg.prototype.seekToFrame = function (seekFrame, seekExact) {\n    if (seekFrame < 0 || seekFrame >= this.frameCount || !this.intraFrames.length) {\n      return false;\n    } // Find the last intra frame before or equal to seek frame\n\n\n    var target = null;\n\n    for (var i = 0; i < this.intraFrames.length && this.intraFrames[i].frame <= seekFrame; i++) {\n      target = this.intraFrames[i];\n    }\n\n    this.buffer.index = target.index;\n    this.currentFrame = target.frame - 1; // If we're seeking to the exact frame, we may have to decode some more frames before\n    // the one we want\n\n    if (seekExact) {\n      for (var frame = target.frame; frame < seekFrame; frame++) {\n        this.decodePicture(DECODE_SKIP_OUTPUT);\n        this.findStartCode(START_PICTURE);\n      }\n\n      this.currentFrame = seekFrame - 1;\n    } // Decode and display the picture we have seeked to\n\n\n    this.decodePicture();\n    return true;\n  };\n\n  jsmpeg.prototype.seekToTime = function (time, seekExact) {\n    this.seekToFrame(time * this.pictureRate | 0, seekExact);\n  };\n\n  jsmpeg.prototype.play = function () {\n    if (this.playing) {\n      return;\n    }\n\n    if (this.progressive) {\n      this.wantsToPlay = true;\n      this.attemptToPlay();\n    } else {\n      this._playNow();\n    }\n  };\n\n  jsmpeg.prototype._playNow = function () {\n    this.targetTime = this.now();\n    this.playing = true;\n    this.scheduleNextFrame();\n  };\n\n  jsmpeg.prototype.pause = function () {\n    this.playing = false;\n    this.wantsToPlay = false;\n  };\n\n  jsmpeg.prototype.stop = function () {\n    this.currentFrame = -1;\n    this.currentTime = 0;\n    this.wantsToPlay = false;\n\n    if (this.buffer) {\n      this.buffer.index = this.firstSequenceHeader;\n    }\n\n    this.playing = false;\n\n    if (this.client) {\n      this.client.close();\n      this.client = null;\n    }\n  }; // ----------------------------------------------------------------------------\n  // Progressive loading via AJAX\n\n\n  jsmpeg.prototype.beginProgressiveLoad = function (url) {\n    this.url = url;\n    this.progressiveLoadPositon = 0;\n    this.fileSize = 0;\n    var request = new XMLHttpRequest();\n    var that = this;\n\n    request.onreadystatechange = function () {\n      if (request.readyState === request.DONE) {\n        that.fileSize = parseInt(request.getResponseHeader(\"Content-Length\"));\n        that.buffer = new BitReader(new ArrayBuffer(that.fileSize));\n        that.buffer.writePos = 0;\n        that.loadNextChunk();\n      }\n    };\n\n    request.open('HEAD', url);\n    request.send();\n  };\n\n  jsmpeg.prototype.maybeLoadNextChunk = function () {\n    if (!this.chunkIsLoading && this.buffer.index >> 3 > this.nextChunkLoadAt && this.progressiveLoadFails < 5) {\n      this.loadNextChunk();\n    }\n  };\n\n  jsmpeg.prototype.loadNextChunk = function () {\n    var that = this;\n    var start = this.buffer.writePos,\n        end = Math.min(this.buffer.writePos + that.progressiveChunkSize - 1, this.fileSize - 1);\n\n    if (start >= this.fileSize) {\n      return;\n    }\n\n    this.chunkIsLoading = true;\n    this.chunkLoadStart = Date.now();\n    var request = new XMLHttpRequest();\n\n    request.onreadystatechange = function () {\n      if (request.readyState === request.DONE && request.status > 200 && request.status < 300) {\n        that.progressiveLoadFails = 0;\n        that.progressiveLoadCallback(request.response);\n      } else if (request.readyState === request.DONE) {\n        // retry\n        that.chunkIsLoading = false;\n        that.progressiveLoadFails++;\n        that.maybeLoadNextChunk();\n      }\n    };\n\n    if (start === 0) {\n      request.onprogress = this.updateLoader.bind(this);\n    }\n\n    request.open('GET', this.url + '?' + start + \"-\" + end);\n    request.setRequestHeader(\"Range\", \"bytes=\" + start + \"-\" + end);\n    request.responseType = \"arraybuffer\";\n    request.send();\n  };\n\n  jsmpeg.prototype.canPlayThrough = false;\n\n  jsmpeg.prototype.progressiveLoadCallback = function (data) {\n    this.chunkIsLoading = false;\n    var isFirstChunk = this.buffer.writePos === 0;\n    var bytes = new Uint8Array(data);\n    this.buffer.bytes.set(bytes, this.buffer.writePos);\n    this.buffer.writePos += bytes.length;\n\n    if (isFirstChunk) {\n      this.findStartCode(START_SEQUENCE);\n      this.firstSequenceHeader = this.buffer.index;\n      this.decodeSequenceHeader();\n    }\n\n    var loadTime = (Date.now() - this.chunkLoadStart) / 1000; // Throttled loading and playback did start already? Calculate when \n    // the next chunk needs to be loaded\n\n    var playIndex = this.buffer.index >> 3;\n    var bytesPerSecondLoaded = bytes.length / loadTime;\n    var bytesPerSecondPlayed = 0;\n\n    if (this.currentTime > 0) {\n      bytesPerSecondPlayed = playIndex / this.currentTime;\n    } else {\n      // Playback didn't start - we need to count the frames we got and estimate the bytes per second\n      var currentIndex = this.buffer.index;\n      this.buffer.index = this.buffer.writePos - bytes.length << 3;\n      var frames;\n\n      for (frames = 0; this.findStartCode(START_PICTURE) !== BitReader.NOT_FOUND; frames++) {}\n\n      this.buffer.index = currentIndex;\n      bytesPerSecondPlayed = bytes.length / (frames / this.pictureRate);\n    }\n\n    var remainingTimeToPlay = (this.buffer.writePos - playIndex) / bytesPerSecondPlayed;\n    var remainingTimeToLoad = (this.fileSize - this.buffer.writePos) / bytesPerSecondLoaded;\n    var totalRemainingPlayTime = (this.fileSize - playIndex) / bytesPerSecondPlayed;\n    this.canPlayThrough = totalRemainingPlayTime > remainingTimeToLoad; // Do we have a lot more remaining play time than we typically need for loading? \n    // -> Increase the chunk size for the next load\n\n    if (remainingTimeToPlay > loadTime * 8) {\n      this.progressiveChunkSize = Math.min(this.progressiveChunkSize * 2, this.progressiveChunkSizeMax);\n    } // Start loading at the latest when only one chunk is left to play, but subtract twice as\n    // much bytes as the next chunk will take to load than it will to play\n\n\n    if (this.progressiveThrottled && this.canPlayThrough) {\n      this.nextChunkLoadAt = this.buffer.writePos - this.progressiveChunkSize * 2 - this.progressiveChunkSize * (bytesPerSecondPlayed / bytesPerSecondLoaded) * 4;\n    } else {\n      this.nextChunkLoadAt = 0;\n    }\n\n    if (this.buffer.writePos >= this.fileSize) {\n      // All loaded. We don't need to schedule another load\n      this.lastFrameIndex = this.buffer.writePos << 3;\n      this.canPlayThrough = true;\n\n      if (this.seekable) {\n        var currentBufferPos = this.buffer.index;\n        this.buffer.index = 0;\n        this.collectIntraFrames();\n        this.buffer.index = currentBufferPos;\n      }\n\n      if (this.externalLoadCallback) {\n        this.externalLoadCallback(this);\n      }\n    } else {\n      this.lastFrameIndex = this.findLastPictureStartCode();\n      this.maybeLoadNextChunk();\n    }\n\n    this.attemptToPlay();\n  };\n\n  jsmpeg.prototype.findLastPictureStartCode = function () {\n    var bufferBytes = this.buffer.bytes;\n\n    for (var i = this.buffer.writePos; i > 3; i--) {\n      if (bufferBytes[i] == START_PICTURE && bufferBytes[i - 1] == 0x01 && bufferBytes[i - 2] == 0x00 && bufferBytes[i - 3] == 0x00) {\n        return i - 3 << 3;\n      }\n    }\n\n    return 0;\n  };\n\n  jsmpeg.prototype.attemptToPlay = function () {\n    if (this.playing || !this.wantsToPlay || !this.canPlayThrough) {\n      return;\n    }\n\n    this._playNow();\n  }; // ----------------------------------------------------------------------------\n  // Utilities\n\n\n  jsmpeg.prototype.readCode = function (codeTable) {\n    var state = 0;\n\n    do {\n      state = codeTable[state + this.buffer.getBits(1)];\n    } while (state >= 0 && codeTable[state] !== 0);\n\n    return codeTable[state + 2];\n  };\n\n  jsmpeg.prototype.findStartCode = function (code) {\n    var current = 0;\n\n    while (true) {\n      current = this.buffer.findNextMPEGStartCode();\n\n      if (current === code || current === BitReader.NOT_FOUND) {\n        return current;\n      }\n    }\n\n    return BitReader.NOT_FOUND;\n  };\n\n  jsmpeg.prototype.fillArray = function (a, value) {\n    for (var i = 0, length = a.length; i < length; i++) {\n      a[i] = value;\n    }\n  }; // ----------------------------------------------------------------------------\n  // Sequence Layer\n\n\n  jsmpeg.prototype.pictureRate = 30;\n  jsmpeg.prototype.lateTime = 0;\n  jsmpeg.prototype.firstSequenceHeader = 0;\n  jsmpeg.prototype.targetTime = 0;\n  jsmpeg.prototype.benchmark = false;\n  jsmpeg.prototype.benchFrame = 0;\n  jsmpeg.prototype.benchDecodeTimes = 0;\n  jsmpeg.prototype.benchAvgFrameTime = 0;\n\n  jsmpeg.prototype.now = function () {\n    return window.performance ? window.performance.now() : Date.now();\n  };\n\n  jsmpeg.prototype.nextFrame = function () {\n    if (!this.buffer) {\n      return;\n    }\n\n    var frameStart = this.now();\n\n    while (true) {\n      var code = this.buffer.findNextMPEGStartCode();\n\n      if (code === START_SEQUENCE) {\n        this.decodeSequenceHeader();\n      } else if (code === START_PICTURE) {\n        if (this.progressive && this.buffer.index >= this.lastFrameIndex) {\n          // Starved\n          this.playing = false;\n          this.maybeLoadNextChunk();\n          return;\n        }\n\n        if (this.playing) {\n          this.scheduleNextFrame();\n        }\n\n        this.decodePicture();\n        this.benchDecodeTimes += this.now() - frameStart;\n        return this.canvas;\n      } else if (code === BitReader.NOT_FOUND) {\n        this.stop(); // Jump back to the beginning\n\n        if (this.externalFinishedCallback) {\n          this.externalFinishedCallback(this);\n        } // Only loop if we found a sequence header\n\n\n        if (this.loop && this.sequenceStarted) {\n          this.play();\n        }\n\n        return null;\n      } else {// ignore (GROUP, USER_DATA, EXTENSION, SLICES...)\n      }\n    }\n  };\n\n  jsmpeg.prototype.scheduleNextFrame = function () {\n    this.lateTime = this.now() - this.targetTime;\n    var wait = Math.max(0, 1000 / this.pictureRate - this.lateTime);\n    this.targetTime = this.now() + wait;\n\n    if (this.benchmark) {\n      this.benchFrame++;\n\n      if (this.benchFrame >= 120) {\n        this.benchAvgFrameTime = this.benchDecodeTimes / this.benchFrame;\n        this.benchFrame = 0;\n        this.benchDecodeTimes = 0;\n\n        if (window.console) {\n          console.log('Average time per frame:', this.benchAvgFrameTime, 'ms');\n        }\n      }\n\n      setTimeout(this.nextFrame.bind(this), 0);\n    }\n\n    setTimeout(this.nextFrame.bind(this), Math.max(wait, 1));\n  };\n\n  jsmpeg.prototype.decodeSequenceHeader = function () {\n    this.width = this.buffer.getBits(12);\n    this.height = this.buffer.getBits(12);\n    this.buffer.advance(4); // skip pixel aspect ratio\n\n    this.pictureRate = PICTURE_RATE[this.buffer.getBits(4)];\n    this.buffer.advance(18 + 1 + 10 + 1); // skip bitRate, marker, bufferSize and constrained bit\n\n    this.initBuffers();\n    var i;\n\n    if (this.buffer.getBits(1)) {\n      // load custom intra quant matrix?\n      for (i = 0; i < 64; i++) {\n        this.customIntraQuantMatrix[ZIG_ZAG[i]] = this.buffer.getBits(8);\n      }\n\n      this.intraQuantMatrix = this.customIntraQuantMatrix;\n    }\n\n    if (this.buffer.getBits(1)) {\n      // load custom non intra quant matrix?\n      for (i = 0; i < 64; i++) {\n        this.customNonIntraQuantMatrix[ZIG_ZAG[i]] = this.buffer.getBits(8);\n      }\n\n      this.nonIntraQuantMatrix = this.customNonIntraQuantMatrix;\n    }\n  };\n\n  jsmpeg.prototype.initBuffers = function () {\n    this.intraQuantMatrix = DEFAULT_INTRA_QUANT_MATRIX;\n    this.nonIntraQuantMatrix = DEFAULT_NON_INTRA_QUANT_MATRIX;\n    this.mbWidth = this.width + 15 >> 4;\n    this.mbHeight = this.height + 15 >> 4;\n    this.mbSize = this.mbWidth * this.mbHeight;\n    this.codedWidth = this.mbWidth << 4;\n    this.codedHeight = this.mbHeight << 4;\n    this.codedSize = this.codedWidth * this.codedHeight;\n    this.halfWidth = this.mbWidth << 3;\n    this.halfHeight = this.mbHeight << 3;\n    this.quarterSize = this.codedSize >> 2; // Sequence already started? Don't allocate buffers again\n\n    if (this.sequenceStarted) {\n      return;\n    }\n\n    this.sequenceStarted = true; // Manually clamp values when writing macroblocks for shitty browsers\n    // that don't support Uint8ClampedArray\n\n    var MaybeClampedUint8Array = window.Uint8ClampedArray || window.Uint8Array;\n\n    if (!window.Uint8ClampedArray) {\n      this.copyBlockToDestination = this.copyBlockToDestinationClamp;\n      this.addBlockToDestination = this.addBlockToDestinationClamp;\n    } // Allocated buffers and resize the canvas\n\n\n    this.currentY = new MaybeClampedUint8Array(this.codedSize);\n    this.currentY32 = new Uint32Array(this.currentY.buffer);\n    this.currentCr = new MaybeClampedUint8Array(this.codedSize >> 2);\n    this.currentCr32 = new Uint32Array(this.currentCr.buffer);\n    this.currentCb = new MaybeClampedUint8Array(this.codedSize >> 2);\n    this.currentCb32 = new Uint32Array(this.currentCb.buffer);\n    this.forwardY = new MaybeClampedUint8Array(this.codedSize);\n    this.forwardY32 = new Uint32Array(this.forwardY.buffer);\n    this.forwardCr = new MaybeClampedUint8Array(this.codedSize >> 2);\n    this.forwardCr32 = new Uint32Array(this.forwardCr.buffer);\n    this.forwardCb = new MaybeClampedUint8Array(this.codedSize >> 2);\n    this.forwardCb32 = new Uint32Array(this.forwardCb.buffer);\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n\n    if (this.gl) {\n      this.gl.useProgram(this.program);\n      this.gl.viewport(0, 0, this.width, this.height);\n    } else {\n      this.currentRGBA = this.canvasContext.getImageData(0, 0, this.width, this.height);\n      this.fillArray(this.currentRGBA.data, 255);\n    }\n  }; // ----------------------------------------------------------------------------\n  // Picture Layer\n\n\n  jsmpeg.prototype.currentY = null;\n  jsmpeg.prototype.currentCr = null;\n  jsmpeg.prototype.currentCb = null;\n  jsmpeg.prototype.currentRGBA = null;\n  jsmpeg.prototype.pictureCodingType = 0; // Buffers for motion compensation\n\n  jsmpeg.prototype.forwardY = null;\n  jsmpeg.prototype.forwardCr = null;\n  jsmpeg.prototype.forwardCb = null;\n  jsmpeg.prototype.fullPelForward = false;\n  jsmpeg.prototype.forwardFCode = 0;\n  jsmpeg.prototype.forwardRSize = 0;\n  jsmpeg.prototype.forwardF = 0;\n\n  jsmpeg.prototype.decodePicture = function (skipOutput) {\n    this.currentFrame++;\n    this.currentTime = this.currentFrame / this.pictureRate;\n\n    if (this.progressive) {\n      this.maybeLoadNextChunk();\n    }\n\n    this.buffer.advance(10); // skip temporalReference\n\n    this.pictureCodingType = this.buffer.getBits(3);\n    this.buffer.advance(16); // skip vbv_delay\n    // Skip B and D frames or unknown coding type\n\n    if (this.pictureCodingType <= 0 || this.pictureCodingType >= PICTURE_TYPE_B) {\n      return;\n    } // full_pel_forward, forward_f_code\n\n\n    if (this.pictureCodingType === PICTURE_TYPE_P) {\n      this.fullPelForward = this.buffer.getBits(1);\n      this.forwardFCode = this.buffer.getBits(3);\n\n      if (this.forwardFCode === 0) {\n        // Ignore picture with zero forward_f_code\n        return;\n      }\n\n      this.forwardRSize = this.forwardFCode - 1;\n      this.forwardF = 1 << this.forwardRSize;\n    }\n\n    var code = 0;\n\n    do {\n      code = this.buffer.findNextMPEGStartCode();\n    } while (code === START_EXTENSION || code === START_USER_DATA);\n\n    while (code >= START_SLICE_FIRST && code <= START_SLICE_LAST) {\n      this.decodeSlice(code & 0x000000FF);\n      code = this.buffer.findNextMPEGStartCode();\n    } // We found the next start code; rewind 32bits and let the main loop handle it.\n\n\n    this.buffer.rewind(32); // Record this frame, if the recorder wants it\n\n    this.recordFrameFromCurrentBuffer();\n\n    if (skipOutput !== DECODE_SKIP_OUTPUT) {\n      this.renderFrame();\n\n      if (this.externalDecodeCallback) {\n        this.externalDecodeCallback(this, this.canvas);\n      }\n    } // If this is a reference picutre then rotate the prediction pointers\n\n\n    if (this.pictureCodingType === PICTURE_TYPE_I || this.pictureCodingType === PICTURE_TYPE_P) {\n      var tmpY = this.forwardY,\n          tmpY32 = this.forwardY32,\n          tmpCr = this.forwardCr,\n          tmpCr32 = this.forwardCr32,\n          tmpCb = this.forwardCb,\n          tmpCb32 = this.forwardCb32;\n      this.forwardY = this.currentY;\n      this.forwardY32 = this.currentY32;\n      this.forwardCr = this.currentCr;\n      this.forwardCr32 = this.currentCr32;\n      this.forwardCb = this.currentCb;\n      this.forwardCb32 = this.currentCb32;\n      this.currentY = tmpY;\n      this.currentY32 = tmpY32;\n      this.currentCr = tmpCr;\n      this.currentCr32 = tmpCr32;\n      this.currentCb = tmpCb;\n      this.currentCb32 = tmpCb32;\n    }\n  };\n\n  jsmpeg.prototype.YCbCrToRGBA = function () {\n    var pY = this.currentY;\n    var pCb = this.currentCb;\n    var pCr = this.currentCr;\n    var pRGBA = this.currentRGBA.data; // Chroma values are the same for each block of 4 pixels, so we proccess\n    // 2 lines at a time, 2 neighboring pixels each.\n    // I wish we could use 32bit writes to the RGBA buffer instead of writing\n    // each byte separately, but we need the automatic clamping of the RGBA\n    // buffer.\n\n    var yIndex1 = 0;\n    var yIndex2 = this.codedWidth;\n    var yNext2Lines = this.codedWidth + (this.codedWidth - this.width);\n    var cIndex = 0;\n    var cNextLine = this.halfWidth - (this.width >> 1);\n    var rgbaIndex1 = 0;\n    var rgbaIndex2 = this.width * 4;\n    var rgbaNext2Lines = this.width * 4;\n    var cols = this.width >> 1;\n    var rows = this.height >> 1;\n    var cb, cr, r, g, b;\n\n    for (var row = 0; row < rows; row++) {\n      for (var col = 0; col < cols; col++) {\n        cb = pCb[cIndex];\n        cr = pCr[cIndex];\n        cIndex++;\n        r = cr + (cr * 103 >> 8) - 179;\n        g = (cb * 88 >> 8) - 44 + (cr * 183 >> 8) - 91;\n        b = cb + (cb * 198 >> 8) - 227; // Line 1\n\n        var y1 = pY[yIndex1++];\n        var y2 = pY[yIndex1++];\n        pRGBA[rgbaIndex1] = y1 + r;\n        pRGBA[rgbaIndex1 + 1] = y1 - g;\n        pRGBA[rgbaIndex1 + 2] = y1 + b;\n        pRGBA[rgbaIndex1 + 4] = y2 + r;\n        pRGBA[rgbaIndex1 + 5] = y2 - g;\n        pRGBA[rgbaIndex1 + 6] = y2 + b;\n        rgbaIndex1 += 8; // Line 2\n\n        var y3 = pY[yIndex2++];\n        var y4 = pY[yIndex2++];\n        pRGBA[rgbaIndex2] = y3 + r;\n        pRGBA[rgbaIndex2 + 1] = y3 - g;\n        pRGBA[rgbaIndex2 + 2] = y3 + b;\n        pRGBA[rgbaIndex2 + 4] = y4 + r;\n        pRGBA[rgbaIndex2 + 5] = y4 - g;\n        pRGBA[rgbaIndex2 + 6] = y4 + b;\n        rgbaIndex2 += 8;\n      }\n\n      yIndex1 += yNext2Lines;\n      yIndex2 += yNext2Lines;\n      rgbaIndex1 += rgbaNext2Lines;\n      rgbaIndex2 += rgbaNext2Lines;\n      cIndex += cNextLine;\n    }\n  };\n\n  jsmpeg.prototype.renderFrame2D = function () {\n    this.YCbCrToRGBA();\n    this.canvasContext.putImageData(this.currentRGBA, 0, 0);\n  }; // ----------------------------------------------------------------------------\n  // Accelerated WebGL YCbCrToRGBA conversion\n\n\n  jsmpeg.prototype.gl = null;\n  jsmpeg.prototype.program = null;\n  jsmpeg.prototype.YTexture = null;\n  jsmpeg.prototype.CBTexture = null;\n  jsmpeg.prototype.CRTexture = null;\n\n  jsmpeg.prototype.createTexture = function (index, name) {\n    var gl = this.gl;\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.uniform1i(gl.getUniformLocation(this.program, name), index);\n    return texture;\n  };\n\n  jsmpeg.prototype.compileShader = function (type, source) {\n    var gl = this.gl;\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      throw new Error(gl.getShaderInfoLog(shader));\n    }\n\n    return shader;\n  };\n\n  jsmpeg.prototype.initWebGL = function () {\n    var gl; // attempt to get a webgl context\n\n    try {\n      gl = this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');\n    } catch (e) {\n      return false;\n    }\n\n    if (!gl) {\n      return false;\n    } // init buffers\n\n\n    this.buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW); // The main YCbCrToRGBA Shader\n\n    this.program = gl.createProgram();\n    gl.attachShader(this.program, this.compileShader(gl.VERTEX_SHADER, SHADER_VERTEX_IDENTITY));\n    gl.attachShader(this.program, this.compileShader(gl.FRAGMENT_SHADER, SHADER_FRAGMENT_YCBCRTORGBA));\n    gl.linkProgram(this.program);\n\n    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n      throw new Error(gl.getProgramInfoLog(this.program));\n    }\n\n    gl.useProgram(this.program); // setup textures\n\n    this.YTexture = this.createTexture(0, 'YTexture');\n    this.CBTexture = this.createTexture(1, 'CBTexture');\n    this.CRTexture = this.createTexture(2, 'CRTexture');\n    var vertexAttr = gl.getAttribLocation(this.program, 'vertex');\n    gl.enableVertexAttribArray(vertexAttr);\n    gl.vertexAttribPointer(vertexAttr, 2, gl.FLOAT, false, 0, 0); // Shader for the loading screen\n\n    this.loadingProgram = gl.createProgram();\n    gl.attachShader(this.loadingProgram, this.compileShader(gl.VERTEX_SHADER, SHADER_VERTEX_IDENTITY));\n    gl.attachShader(this.loadingProgram, this.compileShader(gl.FRAGMENT_SHADER, SHADER_FRAGMENT_LOADING));\n    gl.linkProgram(this.loadingProgram);\n    gl.useProgram(this.loadingProgram);\n    vertexAttr = gl.getAttribLocation(this.loadingProgram, 'vertex');\n    gl.enableVertexAttribArray(vertexAttr);\n    gl.vertexAttribPointer(vertexAttr, 2, gl.FLOAT, false, 0, 0);\n    return true;\n  };\n\n  jsmpeg.prototype.renderFrameGL = function () {\n    var gl = this.gl; // WebGL doesn't like Uint8ClampedArrays, so we have to create a Uint8Array view for\n    // each plane\n\n    var uint8Y = new Uint8Array(this.currentY.buffer),\n        uint8Cr = new Uint8Array(this.currentCr.buffer),\n        uint8Cb = new Uint8Array(this.currentCb.buffer);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.YTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, this.codedWidth, this.height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, uint8Y);\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, this.CBTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, this.halfWidth, this.height / 2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, uint8Cr);\n    gl.activeTexture(gl.TEXTURE2);\n    gl.bindTexture(gl.TEXTURE_2D, this.CRTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, this.halfWidth, this.height / 2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, uint8Cb);\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  }; // ----------------------------------------------------------------------------\n  // Slice Layer\n\n\n  jsmpeg.prototype.quantizerScale = 0;\n  jsmpeg.prototype.sliceBegin = false;\n\n  jsmpeg.prototype.decodeSlice = function (slice) {\n    this.sliceBegin = true;\n    this.macroblockAddress = (slice - 1) * this.mbWidth - 1; // Reset motion vectors and DC predictors\n\n    this.motionFwH = this.motionFwHPrev = 0;\n    this.motionFwV = this.motionFwVPrev = 0;\n    this.dcPredictorY = 128;\n    this.dcPredictorCr = 128;\n    this.dcPredictorCb = 128;\n    this.quantizerScale = this.buffer.getBits(5); // skip extra bits\n\n    while (this.buffer.getBits(1)) {\n      this.buffer.advance(8);\n    }\n\n    do {\n      this.decodeMacroblock(); // We may have to ignore Video Stream Start Codes here (0xE0)!?\n    } while (!this.buffer.nextBytesAreStartCode());\n  }; // ----------------------------------------------------------------------------\n  // Macroblock Layer\n\n\n  jsmpeg.prototype.macroblockAddress = 0;\n  jsmpeg.prototype.mbRow = 0;\n  jsmpeg.prototype.mbCol = 0;\n  jsmpeg.prototype.macroblockType = 0;\n  jsmpeg.prototype.macroblockIntra = false;\n  jsmpeg.prototype.macroblockMotFw = false;\n  jsmpeg.prototype.motionFwH = 0;\n  jsmpeg.prototype.motionFwV = 0;\n  jsmpeg.prototype.motionFwHPrev = 0;\n  jsmpeg.prototype.motionFwVPrev = 0;\n\n  jsmpeg.prototype.decodeMacroblock = function () {\n    // Decode macroblock_address_increment\n    var increment = 0,\n        t = this.readCode(MACROBLOCK_ADDRESS_INCREMENT);\n\n    while (t === 34) {\n      // macroblock_stuffing\n      t = this.readCode(MACROBLOCK_ADDRESS_INCREMENT);\n    }\n\n    while (t === 35) {\n      // macroblock_escape\n      increment += 33;\n      t = this.readCode(MACROBLOCK_ADDRESS_INCREMENT);\n    }\n\n    increment += t; // Process any skipped macroblocks\n\n    if (this.sliceBegin) {\n      // The first macroblock_address_increment of each slice is relative\n      // to beginning of the preverious row, not the preverious macroblock\n      this.sliceBegin = false;\n      this.macroblockAddress += increment;\n    } else {\n      if (this.macroblockAddress + increment >= this.mbSize) {\n        // Illegal (too large) macroblock_address_increment\n        return;\n      }\n\n      if (increment > 1) {\n        // Skipped macroblocks reset DC predictors\n        this.dcPredictorY = 128;\n        this.dcPredictorCr = 128;\n        this.dcPredictorCb = 128; // Skipped macroblocks in P-pictures reset motion vectors\n\n        if (this.pictureCodingType === PICTURE_TYPE_P) {\n          this.motionFwH = this.motionFwHPrev = 0;\n          this.motionFwV = this.motionFwVPrev = 0;\n        }\n      } // Predict skipped macroblocks\n\n\n      while (increment > 1) {\n        this.macroblockAddress++;\n        this.mbRow = this.macroblockAddress / this.mbWidth | 0;\n        this.mbCol = this.macroblockAddress % this.mbWidth;\n        this.copyMacroblock(this.motionFwH, this.motionFwV, this.forwardY, this.forwardCr, this.forwardCb);\n        increment--;\n      }\n\n      this.macroblockAddress++;\n    }\n\n    this.mbRow = this.macroblockAddress / this.mbWidth | 0;\n    this.mbCol = this.macroblockAddress % this.mbWidth; // Process the current macroblock\n\n    this.macroblockType = this.readCode(MACROBLOCK_TYPE_TABLES[this.pictureCodingType]);\n    this.macroblockIntra = this.macroblockType & 0x01;\n    this.macroblockMotFw = this.macroblockType & 0x08; // Quantizer scale\n\n    if ((this.macroblockType & 0x10) !== 0) {\n      this.quantizerScale = this.buffer.getBits(5);\n    }\n\n    if (this.macroblockIntra) {\n      // Intra-coded macroblocks reset motion vectors\n      this.motionFwH = this.motionFwHPrev = 0;\n      this.motionFwV = this.motionFwVPrev = 0;\n    } else {\n      // Non-intra macroblocks reset DC predictors\n      this.dcPredictorY = 128;\n      this.dcPredictorCr = 128;\n      this.dcPredictorCb = 128;\n      this.decodeMotionVectors();\n      this.copyMacroblock(this.motionFwH, this.motionFwV, this.forwardY, this.forwardCr, this.forwardCb);\n    } // Decode blocks\n\n\n    var cbp = (this.macroblockType & 0x02) !== 0 ? this.readCode(CODE_BLOCK_PATTERN) : this.macroblockIntra ? 0x3f : 0;\n\n    for (var block = 0, mask = 0x20; block < 6; block++) {\n      if ((cbp & mask) !== 0) {\n        this.decodeBlock(block);\n      }\n\n      mask >>= 1;\n    }\n  };\n\n  jsmpeg.prototype.decodeMotionVectors = function () {\n    var code,\n        d,\n        r = 0; // Forward\n\n    if (this.macroblockMotFw) {\n      // Horizontal forward\n      code = this.readCode(MOTION);\n\n      if (code !== 0 && this.forwardF !== 1) {\n        r = this.buffer.getBits(this.forwardRSize);\n        d = (Math.abs(code) - 1 << this.forwardRSize) + r + 1;\n\n        if (code < 0) {\n          d = -d;\n        }\n      } else {\n        d = code;\n      }\n\n      this.motionFwHPrev += d;\n\n      if (this.motionFwHPrev > (this.forwardF << 4) - 1) {\n        this.motionFwHPrev -= this.forwardF << 5;\n      } else if (this.motionFwHPrev < -this.forwardF << 4) {\n        this.motionFwHPrev += this.forwardF << 5;\n      }\n\n      this.motionFwH = this.motionFwHPrev;\n\n      if (this.fullPelForward) {\n        this.motionFwH <<= 1;\n      } // Vertical forward\n\n\n      code = this.readCode(MOTION);\n\n      if (code !== 0 && this.forwardF !== 1) {\n        r = this.buffer.getBits(this.forwardRSize);\n        d = (Math.abs(code) - 1 << this.forwardRSize) + r + 1;\n\n        if (code < 0) {\n          d = -d;\n        }\n      } else {\n        d = code;\n      }\n\n      this.motionFwVPrev += d;\n\n      if (this.motionFwVPrev > (this.forwardF << 4) - 1) {\n        this.motionFwVPrev -= this.forwardF << 5;\n      } else if (this.motionFwVPrev < -this.forwardF << 4) {\n        this.motionFwVPrev += this.forwardF << 5;\n      }\n\n      this.motionFwV = this.motionFwVPrev;\n\n      if (this.fullPelForward) {\n        this.motionFwV <<= 1;\n      }\n    } else if (this.pictureCodingType === PICTURE_TYPE_P) {\n      // No motion information in P-picture, reset vectors\n      this.motionFwH = this.motionFwHPrev = 0;\n      this.motionFwV = this.motionFwVPrev = 0;\n    }\n  };\n\n  jsmpeg.prototype.copyMacroblock = function (motionH, motionV, sY, sCr, sCb) {\n    var width, scan, H, V, oddH, oddV, src, dest, last; // We use 32bit writes here\n\n    var dY = this.currentY32;\n    var dCb = this.currentCb32;\n    var dCr = this.currentCr32; // Luminance\n\n    width = this.codedWidth;\n    scan = width - 16;\n    H = motionH >> 1;\n    V = motionV >> 1;\n    oddH = (motionH & 1) === 1;\n    oddV = (motionV & 1) === 1;\n    src = ((this.mbRow << 4) + V) * width + (this.mbCol << 4) + H;\n    dest = this.mbRow * width + this.mbCol << 2;\n    last = dest + (width << 2);\n    var x;\n    var y1, y2, y;\n\n    if (oddH) {\n      if (oddV) {\n        while (dest < last) {\n          y1 = sY[src] + sY[src + width];\n          src++;\n\n          for (x = 0; x < 4; x++) {\n            y2 = sY[src] + sY[src + width];\n            src++;\n            y = y1 + y2 + 2 >> 2 & 0xff;\n            y1 = sY[src] + sY[src + width];\n            src++;\n            y |= y1 + y2 + 2 << 6 & 0xff00;\n            y2 = sY[src] + sY[src + width];\n            src++;\n            y |= y1 + y2 + 2 << 14 & 0xff0000;\n            y1 = sY[src] + sY[src + width];\n            src++;\n            y |= y1 + y2 + 2 << 22 & 0xff000000;\n            dY[dest++] = y;\n          }\n\n          dest += scan >> 2;\n          src += scan - 1;\n        }\n      } else {\n        while (dest < last) {\n          y1 = sY[src++];\n\n          for (x = 0; x < 4; x++) {\n            y2 = sY[src++];\n            y = y1 + y2 + 1 >> 1 & 0xff;\n            y1 = sY[src++];\n            y |= y1 + y2 + 1 << 7 & 0xff00;\n            y2 = sY[src++];\n            y |= y1 + y2 + 1 << 15 & 0xff0000;\n            y1 = sY[src++];\n            y |= y1 + y2 + 1 << 23 & 0xff000000;\n            dY[dest++] = y;\n          }\n\n          dest += scan >> 2;\n          src += scan - 1;\n        }\n      }\n    } else {\n      if (oddV) {\n        while (dest < last) {\n          for (x = 0; x < 4; x++) {\n            y = sY[src] + sY[src + width] + 1 >> 1 & 0xff;\n            src++;\n            y |= sY[src] + sY[src + width] + 1 << 7 & 0xff00;\n            src++;\n            y |= sY[src] + sY[src + width] + 1 << 15 & 0xff0000;\n            src++;\n            y |= sY[src] + sY[src + width] + 1 << 23 & 0xff000000;\n            src++;\n            dY[dest++] = y;\n          }\n\n          dest += scan >> 2;\n          src += scan;\n        }\n      } else {\n        while (dest < last) {\n          for (x = 0; x < 4; x++) {\n            y = sY[src];\n            src++;\n            y |= sY[src] << 8;\n            src++;\n            y |= sY[src] << 16;\n            src++;\n            y |= sY[src] << 24;\n            src++;\n            dY[dest++] = y;\n          }\n\n          dest += scan >> 2;\n          src += scan;\n        }\n      }\n    } // Chrominance\n\n\n    width = this.halfWidth;\n    scan = width - 8;\n    H = motionH / 2 >> 1;\n    V = motionV / 2 >> 1;\n    oddH = (motionH / 2 & 1) === 1;\n    oddV = (motionV / 2 & 1) === 1;\n    src = ((this.mbRow << 3) + V) * width + (this.mbCol << 3) + H;\n    dest = this.mbRow * width + this.mbCol << 1;\n    last = dest + (width << 1);\n    var cr1, cr2, cr;\n    var cb1, cb2, cb;\n\n    if (oddH) {\n      if (oddV) {\n        while (dest < last) {\n          cr1 = sCr[src] + sCr[src + width];\n          cb1 = sCb[src] + sCb[src + width];\n          src++;\n\n          for (x = 0; x < 2; x++) {\n            cr2 = sCr[src] + sCr[src + width];\n            cb2 = sCb[src] + sCb[src + width];\n            src++;\n            cr = cr1 + cr2 + 2 >> 2 & 0xff;\n            cb = cb1 + cb2 + 2 >> 2 & 0xff;\n            cr1 = sCr[src] + sCr[src + width];\n            cb1 = sCb[src] + sCb[src + width];\n            src++;\n            cr |= cr1 + cr2 + 2 << 6 & 0xff00;\n            cb |= cb1 + cb2 + 2 << 6 & 0xff00;\n            cr2 = sCr[src] + sCr[src + width];\n            cb2 = sCb[src] + sCb[src + width];\n            src++;\n            cr |= cr1 + cr2 + 2 << 14 & 0xff0000;\n            cb |= cb1 + cb2 + 2 << 14 & 0xff0000;\n            cr1 = sCr[src] + sCr[src + width];\n            cb1 = sCb[src] + sCb[src + width];\n            src++;\n            cr |= cr1 + cr2 + 2 << 22 & 0xff000000;\n            cb |= cb1 + cb2 + 2 << 22 & 0xff000000;\n            dCr[dest] = cr;\n            dCb[dest] = cb;\n            dest++;\n          }\n\n          dest += scan >> 2;\n          src += scan - 1;\n        }\n      } else {\n        while (dest < last) {\n          cr1 = sCr[src];\n          cb1 = sCb[src];\n          src++;\n\n          for (x = 0; x < 2; x++) {\n            cr2 = sCr[src];\n            cb2 = sCb[src++];\n            cr = cr1 + cr2 + 1 >> 1 & 0xff;\n            cb = cb1 + cb2 + 1 >> 1 & 0xff;\n            cr1 = sCr[src];\n            cb1 = sCb[src++];\n            cr |= cr1 + cr2 + 1 << 7 & 0xff00;\n            cb |= cb1 + cb2 + 1 << 7 & 0xff00;\n            cr2 = sCr[src];\n            cb2 = sCb[src++];\n            cr |= cr1 + cr2 + 1 << 15 & 0xff0000;\n            cb |= cb1 + cb2 + 1 << 15 & 0xff0000;\n            cr1 = sCr[src];\n            cb1 = sCb[src++];\n            cr |= cr1 + cr2 + 1 << 23 & 0xff000000;\n            cb |= cb1 + cb2 + 1 << 23 & 0xff000000;\n            dCr[dest] = cr;\n            dCb[dest] = cb;\n            dest++;\n          }\n\n          dest += scan >> 2;\n          src += scan - 1;\n        }\n      }\n    } else {\n      if (oddV) {\n        while (dest < last) {\n          for (x = 0; x < 2; x++) {\n            cr = sCr[src] + sCr[src + width] + 1 >> 1 & 0xff;\n            cb = sCb[src] + sCb[src + width] + 1 >> 1 & 0xff;\n            src++;\n            cr |= sCr[src] + sCr[src + width] + 1 << 7 & 0xff00;\n            cb |= sCb[src] + sCb[src + width] + 1 << 7 & 0xff00;\n            src++;\n            cr |= sCr[src] + sCr[src + width] + 1 << 15 & 0xff0000;\n            cb |= sCb[src] + sCb[src + width] + 1 << 15 & 0xff0000;\n            src++;\n            cr |= sCr[src] + sCr[src + width] + 1 << 23 & 0xff000000;\n            cb |= sCb[src] + sCb[src + width] + 1 << 23 & 0xff000000;\n            src++;\n            dCr[dest] = cr;\n            dCb[dest] = cb;\n            dest++;\n          }\n\n          dest += scan >> 2;\n          src += scan;\n        }\n      } else {\n        while (dest < last) {\n          for (x = 0; x < 2; x++) {\n            cr = sCr[src];\n            cb = sCb[src];\n            src++;\n            cr |= sCr[src] << 8;\n            cb |= sCb[src] << 8;\n            src++;\n            cr |= sCr[src] << 16;\n            cb |= sCb[src] << 16;\n            src++;\n            cr |= sCr[src] << 24;\n            cb |= sCb[src] << 24;\n            src++;\n            dCr[dest] = cr;\n            dCb[dest] = cb;\n            dest++;\n          }\n\n          dest += scan >> 2;\n          src += scan;\n        }\n      }\n    }\n  }; // ----------------------------------------------------------------------------\n  // Block layer\n  //jsmpeg.prototype.dcPredictorY;\n  //jsmpeg.prototype.dcPredictorCr;\n  //jsmpeg.prototype.dcPredictorCb;\n\n\n  jsmpeg.prototype.blockData = null;\n\n  jsmpeg.prototype.decodeBlock = function (block) {\n    var n = 0,\n        quantMatrix; // Decode DC coefficient of intra-coded blocks\n\n    if (this.macroblockIntra) {\n      var predictor, dctSize; // DC prediction\n\n      if (block < 4) {\n        predictor = this.dcPredictorY;\n        dctSize = this.readCode(DCT_DC_SIZE_LUMINANCE);\n      } else {\n        predictor = block === 4 ? this.dcPredictorCr : this.dcPredictorCb;\n        dctSize = this.readCode(DCT_DC_SIZE_CHROMINANCE);\n      } // Read DC coeff\n\n\n      if (dctSize > 0) {\n        var differential = this.buffer.getBits(dctSize);\n\n        if ((differential & 1 << dctSize - 1) !== 0) {\n          this.blockData[0] = predictor + differential;\n        } else {\n          this.blockData[0] = predictor + (-1 << dctSize | differential + 1);\n        }\n      } else {\n        this.blockData[0] = predictor;\n      } // Save predictor value\n\n\n      if (block < 4) {\n        this.dcPredictorY = this.blockData[0];\n      } else if (block === 4) {\n        this.dcPredictorCr = this.blockData[0];\n      } else {\n        this.dcPredictorCb = this.blockData[0];\n      } // Dequantize + premultiply\n\n\n      this.blockData[0] <<= 3 + 5;\n      quantMatrix = this.intraQuantMatrix;\n      n = 1;\n    } else {\n      quantMatrix = this.nonIntraQuantMatrix;\n    } // Decode AC coefficients (+DC for non-intra)\n\n\n    var level = 0;\n\n    while (true) {\n      var run = 0,\n          coeff = this.readCode(DCT_COEFF);\n\n      if (coeff === 0x0001 && n > 0 && this.buffer.getBits(1) === 0) {\n        // end_of_block\n        break;\n      }\n\n      if (coeff === 0xffff) {\n        // escape\n        run = this.buffer.getBits(6);\n        level = this.buffer.getBits(8);\n\n        if (level === 0) {\n          level = this.buffer.getBits(8);\n        } else if (level === 128) {\n          level = this.buffer.getBits(8) - 256;\n        } else if (level > 128) {\n          level = level - 256;\n        }\n      } else {\n        run = coeff >> 8;\n        level = coeff & 0xff;\n\n        if (this.buffer.getBits(1)) {\n          level = -level;\n        }\n      }\n\n      n += run;\n      var dezigZagged = ZIG_ZAG[n];\n      n++; // Dequantize, oddify, clip\n\n      level <<= 1;\n\n      if (!this.macroblockIntra) {\n        level += level < 0 ? -1 : 1;\n      }\n\n      level = level * this.quantizerScale * quantMatrix[dezigZagged] >> 4;\n\n      if ((level & 1) === 0) {\n        level -= level > 0 ? 1 : -1;\n      }\n\n      if (level > 2047) {\n        level = 2047;\n      } else if (level < -2048) {\n        level = -2048;\n      } // Save premultiplied coefficient\n\n\n      this.blockData[dezigZagged] = level * PREMULTIPLIER_MATRIX[dezigZagged];\n    } // Move block to its place\n\n\n    var destArray, destIndex, scan;\n\n    if (block < 4) {\n      destArray = this.currentY;\n      scan = this.codedWidth - 8;\n      destIndex = this.mbRow * this.codedWidth + this.mbCol << 4;\n\n      if ((block & 1) !== 0) {\n        destIndex += 8;\n      }\n\n      if ((block & 2) !== 0) {\n        destIndex += this.codedWidth << 3;\n      }\n    } else {\n      destArray = block === 4 ? this.currentCb : this.currentCr;\n      scan = (this.codedWidth >> 1) - 8;\n      destIndex = (this.mbRow * this.codedWidth << 2) + (this.mbCol << 3);\n    }\n\n    if (this.macroblockIntra) {\n      // Overwrite (no prediction)\n      if (n === 1) {\n        this.copyValueToDestination(this.blockData[0] + 128 >> 8, destArray, destIndex, scan);\n        this.blockData[0] = 0;\n      } else {\n        this.IDCT();\n        this.copyBlockToDestination(this.blockData, destArray, destIndex, scan);\n        this.blockData.set(this.zeroBlockData);\n      }\n    } else {\n      // Add data to the predicted macroblock\n      if (n === 1) {\n        this.addValueToDestination(this.blockData[0] + 128 >> 8, destArray, destIndex, scan);\n        this.blockData[0] = 0;\n      } else {\n        this.IDCT();\n        this.addBlockToDestination(this.blockData, destArray, destIndex, scan);\n        this.blockData.set(this.zeroBlockData);\n      }\n    }\n\n    n = 0;\n  };\n\n  jsmpeg.prototype.copyBlockToDestination = function (blockData, destArray, destIndex, scan) {\n    for (var n = 0; n < 64; n += 8, destIndex += scan + 8) {\n      destArray[destIndex + 0] = blockData[n + 0];\n      destArray[destIndex + 1] = blockData[n + 1];\n      destArray[destIndex + 2] = blockData[n + 2];\n      destArray[destIndex + 3] = blockData[n + 3];\n      destArray[destIndex + 4] = blockData[n + 4];\n      destArray[destIndex + 5] = blockData[n + 5];\n      destArray[destIndex + 6] = blockData[n + 6];\n      destArray[destIndex + 7] = blockData[n + 7];\n    }\n  };\n\n  jsmpeg.prototype.addBlockToDestination = function (blockData, destArray, destIndex, scan) {\n    for (var n = 0; n < 64; n += 8, destIndex += scan + 8) {\n      destArray[destIndex + 0] += blockData[n + 0];\n      destArray[destIndex + 1] += blockData[n + 1];\n      destArray[destIndex + 2] += blockData[n + 2];\n      destArray[destIndex + 3] += blockData[n + 3];\n      destArray[destIndex + 4] += blockData[n + 4];\n      destArray[destIndex + 5] += blockData[n + 5];\n      destArray[destIndex + 6] += blockData[n + 6];\n      destArray[destIndex + 7] += blockData[n + 7];\n    }\n  };\n\n  jsmpeg.prototype.copyValueToDestination = function (value, destArray, destIndex, scan) {\n    for (var n = 0; n < 64; n += 8, destIndex += scan + 8) {\n      destArray[destIndex + 0] = value;\n      destArray[destIndex + 1] = value;\n      destArray[destIndex + 2] = value;\n      destArray[destIndex + 3] = value;\n      destArray[destIndex + 4] = value;\n      destArray[destIndex + 5] = value;\n      destArray[destIndex + 6] = value;\n      destArray[destIndex + 7] = value;\n    }\n  };\n\n  jsmpeg.prototype.addValueToDestination = function (value, destArray, destIndex, scan) {\n    for (var n = 0; n < 64; n += 8, destIndex += scan + 8) {\n      destArray[destIndex + 0] += value;\n      destArray[destIndex + 1] += value;\n      destArray[destIndex + 2] += value;\n      destArray[destIndex + 3] += value;\n      destArray[destIndex + 4] += value;\n      destArray[destIndex + 5] += value;\n      destArray[destIndex + 6] += value;\n      destArray[destIndex + 7] += value;\n    }\n  }; // Clamping version for shitty browsers (IE) that don't support Uint8ClampedArray\n\n\n  jsmpeg.prototype.copyBlockToDestinationClamp = function (blockData, destArray, destIndex, scan) {\n    var n = 0;\n\n    for (var i = 0; i < 8; i++) {\n      for (var j = 0; j < 8; j++) {\n        var p = blockData[n++];\n        destArray[destIndex++] = p > 255 ? 255 : p < 0 ? 0 : p;\n      }\n\n      destIndex += scan;\n    }\n  };\n\n  jsmpeg.prototype.addBlockToDestinationClamp = function (blockData, destArray, destIndex, scan) {\n    var n = 0;\n\n    for (var i = 0; i < 8; i++) {\n      for (var j = 0; j < 8; j++) {\n        var p = blockData[n++] + destArray[destIndex];\n        destArray[destIndex++] = p > 255 ? 255 : p < 0 ? 0 : p;\n      }\n\n      destIndex += scan;\n    }\n  };\n\n  jsmpeg.prototype.IDCT = function () {\n    // See http://vsr.informatik.tu-chemnitz.de/~jan/MPEG/HTML/IDCT.html\n    // for more info.\n    var b1,\n        b3,\n        b4,\n        b6,\n        b7,\n        tmp1,\n        tmp2,\n        m0,\n        x0,\n        x1,\n        x2,\n        x3,\n        x4,\n        y3,\n        y4,\n        y5,\n        y6,\n        y7,\n        i,\n        blockData = this.blockData; // Transform columns\n\n    for (i = 0; i < 8; ++i) {\n      b1 = blockData[4 * 8 + i];\n      b3 = blockData[2 * 8 + i] + blockData[6 * 8 + i];\n      b4 = blockData[5 * 8 + i] - blockData[3 * 8 + i];\n      tmp1 = blockData[1 * 8 + i] + blockData[7 * 8 + i];\n      tmp2 = blockData[3 * 8 + i] + blockData[5 * 8 + i];\n      b6 = blockData[1 * 8 + i] - blockData[7 * 8 + i];\n      b7 = tmp1 + tmp2;\n      m0 = blockData[0 * 8 + i];\n      x4 = (b6 * 473 - b4 * 196 + 128 >> 8) - b7;\n      x0 = x4 - ((tmp1 - tmp2) * 362 + 128 >> 8);\n      x1 = m0 - b1;\n      x2 = ((blockData[2 * 8 + i] - blockData[6 * 8 + i]) * 362 + 128 >> 8) - b3;\n      x3 = m0 + b1;\n      y3 = x1 + x2;\n      y4 = x3 + b3;\n      y5 = x1 - x2;\n      y6 = x3 - b3;\n      y7 = -x0 - (b4 * 473 + b6 * 196 + 128 >> 8);\n      blockData[0 * 8 + i] = b7 + y4;\n      blockData[1 * 8 + i] = x4 + y3;\n      blockData[2 * 8 + i] = y5 - x0;\n      blockData[3 * 8 + i] = y6 - y7;\n      blockData[4 * 8 + i] = y6 + y7;\n      blockData[5 * 8 + i] = x0 + y5;\n      blockData[6 * 8 + i] = y3 - x4;\n      blockData[7 * 8 + i] = y4 - b7;\n    } // Transform rows\n\n\n    for (i = 0; i < 64; i += 8) {\n      b1 = blockData[4 + i];\n      b3 = blockData[2 + i] + blockData[6 + i];\n      b4 = blockData[5 + i] - blockData[3 + i];\n      tmp1 = blockData[1 + i] + blockData[7 + i];\n      tmp2 = blockData[3 + i] + blockData[5 + i];\n      b6 = blockData[1 + i] - blockData[7 + i];\n      b7 = tmp1 + tmp2;\n      m0 = blockData[0 + i];\n      x4 = (b6 * 473 - b4 * 196 + 128 >> 8) - b7;\n      x0 = x4 - ((tmp1 - tmp2) * 362 + 128 >> 8);\n      x1 = m0 - b1;\n      x2 = ((blockData[2 + i] - blockData[6 + i]) * 362 + 128 >> 8) - b3;\n      x3 = m0 + b1;\n      y3 = x1 + x2;\n      y4 = x3 + b3;\n      y5 = x1 - x2;\n      y6 = x3 - b3;\n      y7 = -x0 - (b4 * 473 + b6 * 196 + 128 >> 8);\n      blockData[0 + i] = b7 + y4 + 128 >> 8;\n      blockData[1 + i] = x4 + y3 + 128 >> 8;\n      blockData[2 + i] = y5 - x0 + 128 >> 8;\n      blockData[3 + i] = y6 - y7 + 128 >> 8;\n      blockData[4 + i] = y6 + y7 + 128 >> 8;\n      blockData[5 + i] = x0 + y5 + 128 >> 8;\n      blockData[6 + i] = y3 - x4 + 128 >> 8;\n      blockData[7 + i] = y4 - b7 + 128 >> 8;\n    }\n  }; // ----------------------------------------------------------------------------\n  // VLC Tables and Constants\n\n\n  var SOCKET_MAGIC_BYTES = 'jsmp',\n      DECODE_SKIP_OUTPUT = 1,\n      PICTURE_RATE = [0.000, 23.976, 24.000, 25.000, 29.970, 30.000, 50.000, 59.940, 60.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000],\n      ZIG_ZAG = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]),\n      DEFAULT_INTRA_QUANT_MATRIX = new Uint8Array([8, 16, 19, 22, 26, 27, 29, 34, 16, 16, 22, 24, 27, 29, 34, 37, 19, 22, 26, 27, 29, 34, 34, 38, 22, 22, 26, 27, 29, 34, 37, 40, 22, 26, 27, 29, 32, 35, 40, 48, 26, 27, 29, 32, 35, 40, 48, 58, 26, 27, 29, 34, 38, 46, 56, 69, 27, 29, 35, 38, 46, 56, 69, 83]),\n      DEFAULT_NON_INTRA_QUANT_MATRIX = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]),\n      PREMULTIPLIER_MATRIX = new Uint8Array([32, 44, 42, 38, 32, 25, 17, 9, 44, 62, 58, 52, 44, 35, 24, 12, 42, 58, 55, 49, 42, 33, 23, 12, 38, 52, 49, 44, 38, 30, 20, 10, 32, 44, 42, 38, 32, 25, 17, 9, 25, 35, 33, 30, 25, 20, 14, 7, 17, 24, 23, 20, 17, 14, 9, 5, 9, 12, 12, 10, 9, 7, 5, 2]),\n      // MPEG-1 VLC\n  //  macroblock_stuffing decodes as 34.\n  //  macroblock_escape decodes as 35.\n  MACROBLOCK_ADDRESS_INCREMENT = new Int16Array([1 * 3, 2 * 3, 0, //   0\n  3 * 3, 4 * 3, 0, //   1  0\n  0, 0, 1, //   2  1.\n  5 * 3, 6 * 3, 0, //   3  00\n  7 * 3, 8 * 3, 0, //   4  01\n  9 * 3, 10 * 3, 0, //   5  000\n  11 * 3, 12 * 3, 0, //   6  001\n  0, 0, 3, //   7  010.\n  0, 0, 2, //   8  011.\n  13 * 3, 14 * 3, 0, //   9  0000\n  15 * 3, 16 * 3, 0, //  10  0001\n  0, 0, 5, //  11  0010.\n  0, 0, 4, //  12  0011.\n  17 * 3, 18 * 3, 0, //  13  0000 0\n  19 * 3, 20 * 3, 0, //  14  0000 1\n  0, 0, 7, //  15  0001 0.\n  0, 0, 6, //  16  0001 1.\n  21 * 3, 22 * 3, 0, //  17  0000 00\n  23 * 3, 24 * 3, 0, //  18  0000 01\n  25 * 3, 26 * 3, 0, //  19  0000 10\n  27 * 3, 28 * 3, 0, //  20  0000 11\n  -1, 29 * 3, 0, //  21  0000 000\n  -1, 30 * 3, 0, //  22  0000 001\n  31 * 3, 32 * 3, 0, //  23  0000 010\n  33 * 3, 34 * 3, 0, //  24  0000 011\n  35 * 3, 36 * 3, 0, //  25  0000 100\n  37 * 3, 38 * 3, 0, //  26  0000 101\n  0, 0, 9, //  27  0000 110.\n  0, 0, 8, //  28  0000 111.\n  39 * 3, 40 * 3, 0, //  29  0000 0001\n  41 * 3, 42 * 3, 0, //  30  0000 0011\n  43 * 3, 44 * 3, 0, //  31  0000 0100\n  45 * 3, 46 * 3, 0, //  32  0000 0101\n  0, 0, 15, //  33  0000 0110.\n  0, 0, 14, //  34  0000 0111.\n  0, 0, 13, //  35  0000 1000.\n  0, 0, 12, //  36  0000 1001.\n  0, 0, 11, //  37  0000 1010.\n  0, 0, 10, //  38  0000 1011.\n  47 * 3, -1, 0, //  39  0000 0001 0\n  -1, 48 * 3, 0, //  40  0000 0001 1\n  49 * 3, 50 * 3, 0, //  41  0000 0011 0\n  51 * 3, 52 * 3, 0, //  42  0000 0011 1\n  53 * 3, 54 * 3, 0, //  43  0000 0100 0\n  55 * 3, 56 * 3, 0, //  44  0000 0100 1\n  57 * 3, 58 * 3, 0, //  45  0000 0101 0\n  59 * 3, 60 * 3, 0, //  46  0000 0101 1\n  61 * 3, -1, 0, //  47  0000 0001 00\n  -1, 62 * 3, 0, //  48  0000 0001 11\n  63 * 3, 64 * 3, 0, //  49  0000 0011 00\n  65 * 3, 66 * 3, 0, //  50  0000 0011 01\n  67 * 3, 68 * 3, 0, //  51  0000 0011 10\n  69 * 3, 70 * 3, 0, //  52  0000 0011 11\n  71 * 3, 72 * 3, 0, //  53  0000 0100 00\n  73 * 3, 74 * 3, 0, //  54  0000 0100 01\n  0, 0, 21, //  55  0000 0100 10.\n  0, 0, 20, //  56  0000 0100 11.\n  0, 0, 19, //  57  0000 0101 00.\n  0, 0, 18, //  58  0000 0101 01.\n  0, 0, 17, //  59  0000 0101 10.\n  0, 0, 16, //  60  0000 0101 11.\n  0, 0, 35, //  61  0000 0001 000. -- macroblock_escape\n  0, 0, 34, //  62  0000 0001 111. -- macroblock_stuffing\n  0, 0, 33, //  63  0000 0011 000.\n  0, 0, 32, //  64  0000 0011 001.\n  0, 0, 31, //  65  0000 0011 010.\n  0, 0, 30, //  66  0000 0011 011.\n  0, 0, 29, //  67  0000 0011 100.\n  0, 0, 28, //  68  0000 0011 101.\n  0, 0, 27, //  69  0000 0011 110.\n  0, 0, 26, //  70  0000 0011 111.\n  0, 0, 25, //  71  0000 0100 000.\n  0, 0, 24, //  72  0000 0100 001.\n  0, 0, 23, //  73  0000 0100 010.\n  0, 0, 22 //  74  0000 0100 011.\n  ]),\n      //  macroblock_type bitmap:\n  //    0x10  macroblock_quant\n  //    0x08  macroblock_motion_forward\n  //    0x04  macroblock_motion_backward\n  //    0x02  macrobkock_pattern\n  //    0x01  macroblock_intra\n  //\n  MACROBLOCK_TYPE_I = new Int8Array([1 * 3, 2 * 3, 0, //   0\n  -1, 3 * 3, 0, //   1  0\n  0, 0, 0x01, //   2  1.\n  0, 0, 0x11 //   3  01.\n  ]),\n      MACROBLOCK_TYPE_P = new Int8Array([1 * 3, 2 * 3, 0, //  0\n  3 * 3, 4 * 3, 0, //  1  0\n  0, 0, 0x0a, //  2  1.\n  5 * 3, 6 * 3, 0, //  3  00\n  0, 0, 0x02, //  4  01.\n  7 * 3, 8 * 3, 0, //  5  000\n  0, 0, 0x08, //  6  001.\n  9 * 3, 10 * 3, 0, //  7  0000\n  11 * 3, 12 * 3, 0, //  8  0001\n  -1, 13 * 3, 0, //  9  00000\n  0, 0, 0x12, // 10  00001.\n  0, 0, 0x1a, // 11  00010.\n  0, 0, 0x01, // 12  00011.\n  0, 0, 0x11 // 13  000001.\n  ]),\n      MACROBLOCK_TYPE_B = new Int8Array([1 * 3, 2 * 3, 0, //  0\n  3 * 3, 5 * 3, 0, //  1  0\n  4 * 3, 6 * 3, 0, //  2  1\n  8 * 3, 7 * 3, 0, //  3  00\n  0, 0, 0x0c, //  4  10.\n  9 * 3, 10 * 3, 0, //  5  01\n  0, 0, 0x0e, //  6  11.\n  13 * 3, 14 * 3, 0, //  7  001\n  12 * 3, 11 * 3, 0, //  8  000\n  0, 0, 0x04, //  9  010.\n  0, 0, 0x06, // 10  011.\n  18 * 3, 16 * 3, 0, // 11  0001\n  15 * 3, 17 * 3, 0, // 12  0000\n  0, 0, 0x08, // 13  0010.\n  0, 0, 0x0a, // 14  0011.\n  -1, 19 * 3, 0, // 15  00000\n  0, 0, 0x01, // 16  00011.\n  20 * 3, 21 * 3, 0, // 17  00001\n  0, 0, 0x1e, // 18  00010.\n  0, 0, 0x11, // 19  000001.\n  0, 0, 0x16, // 20  000010.\n  0, 0, 0x1a // 21  000011.\n  ]),\n      CODE_BLOCK_PATTERN = new Int16Array([2 * 3, 1 * 3, 0, //   0\n  3 * 3, 6 * 3, 0, //   1  1\n  4 * 3, 5 * 3, 0, //   2  0\n  8 * 3, 11 * 3, 0, //   3  10\n  12 * 3, 13 * 3, 0, //   4  00\n  9 * 3, 7 * 3, 0, //   5  01\n  10 * 3, 14 * 3, 0, //   6  11\n  20 * 3, 19 * 3, 0, //   7  011\n  18 * 3, 16 * 3, 0, //   8  100\n  23 * 3, 17 * 3, 0, //   9  010\n  27 * 3, 25 * 3, 0, //  10  110\n  21 * 3, 28 * 3, 0, //  11  101\n  15 * 3, 22 * 3, 0, //  12  000\n  24 * 3, 26 * 3, 0, //  13  001\n  0, 0, 60, //  14  111.\n  35 * 3, 40 * 3, 0, //  15  0000\n  44 * 3, 48 * 3, 0, //  16  1001\n  38 * 3, 36 * 3, 0, //  17  0101\n  42 * 3, 47 * 3, 0, //  18  1000\n  29 * 3, 31 * 3, 0, //  19  0111\n  39 * 3, 32 * 3, 0, //  20  0110\n  0, 0, 32, //  21  1010.\n  45 * 3, 46 * 3, 0, //  22  0001\n  33 * 3, 41 * 3, 0, //  23  0100\n  43 * 3, 34 * 3, 0, //  24  0010\n  0, 0, 4, //  25  1101.\n  30 * 3, 37 * 3, 0, //  26  0011\n  0, 0, 8, //  27  1100.\n  0, 0, 16, //  28  1011.\n  0, 0, 44, //  29  0111 0.\n  50 * 3, 56 * 3, 0, //  30  0011 0\n  0, 0, 28, //  31  0111 1.\n  0, 0, 52, //  32  0110 1.\n  0, 0, 62, //  33  0100 0.\n  61 * 3, 59 * 3, 0, //  34  0010 1\n  52 * 3, 60 * 3, 0, //  35  0000 0\n  0, 0, 1, //  36  0101 1.\n  55 * 3, 54 * 3, 0, //  37  0011 1\n  0, 0, 61, //  38  0101 0.\n  0, 0, 56, //  39  0110 0.\n  57 * 3, 58 * 3, 0, //  40  0000 1\n  0, 0, 2, //  41  0100 1.\n  0, 0, 40, //  42  1000 0.\n  51 * 3, 62 * 3, 0, //  43  0010 0\n  0, 0, 48, //  44  1001 0.\n  64 * 3, 63 * 3, 0, //  45  0001 0\n  49 * 3, 53 * 3, 0, //  46  0001 1\n  0, 0, 20, //  47  1000 1.\n  0, 0, 12, //  48  1001 1.\n  80 * 3, 83 * 3, 0, //  49  0001 10\n  0, 0, 63, //  50  0011 00.\n  77 * 3, 75 * 3, 0, //  51  0010 00\n  65 * 3, 73 * 3, 0, //  52  0000 00\n  84 * 3, 66 * 3, 0, //  53  0001 11\n  0, 0, 24, //  54  0011 11.\n  0, 0, 36, //  55  0011 10.\n  0, 0, 3, //  56  0011 01.\n  69 * 3, 87 * 3, 0, //  57  0000 10\n  81 * 3, 79 * 3, 0, //  58  0000 11\n  68 * 3, 71 * 3, 0, //  59  0010 11\n  70 * 3, 78 * 3, 0, //  60  0000 01\n  67 * 3, 76 * 3, 0, //  61  0010 10\n  72 * 3, 74 * 3, 0, //  62  0010 01\n  86 * 3, 85 * 3, 0, //  63  0001 01\n  88 * 3, 82 * 3, 0, //  64  0001 00\n  -1, 94 * 3, 0, //  65  0000 000\n  95 * 3, 97 * 3, 0, //  66  0001 111\n  0, 0, 33, //  67  0010 100.\n  0, 0, 9, //  68  0010 110.\n  106 * 3, 110 * 3, 0, //  69  0000 100\n  102 * 3, 116 * 3, 0, //  70  0000 010\n  0, 0, 5, //  71  0010 111.\n  0, 0, 10, //  72  0010 010.\n  93 * 3, 89 * 3, 0, //  73  0000 001\n  0, 0, 6, //  74  0010 011.\n  0, 0, 18, //  75  0010 001.\n  0, 0, 17, //  76  0010 101.\n  0, 0, 34, //  77  0010 000.\n  113 * 3, 119 * 3, 0, //  78  0000 011\n  103 * 3, 104 * 3, 0, //  79  0000 111\n  90 * 3, 92 * 3, 0, //  80  0001 100\n  109 * 3, 107 * 3, 0, //  81  0000 110\n  117 * 3, 118 * 3, 0, //  82  0001 001\n  101 * 3, 99 * 3, 0, //  83  0001 101\n  98 * 3, 96 * 3, 0, //  84  0001 110\n  100 * 3, 91 * 3, 0, //  85  0001 011\n  114 * 3, 115 * 3, 0, //  86  0001 010\n  105 * 3, 108 * 3, 0, //  87  0000 101\n  112 * 3, 111 * 3, 0, //  88  0001 000\n  121 * 3, 125 * 3, 0, //  89  0000 0011\n  0, 0, 41, //  90  0001 1000.\n  0, 0, 14, //  91  0001 0111.\n  0, 0, 21, //  92  0001 1001.\n  124 * 3, 122 * 3, 0, //  93  0000 0010\n  120 * 3, 123 * 3, 0, //  94  0000 0001\n  0, 0, 11, //  95  0001 1110.\n  0, 0, 19, //  96  0001 1101.\n  0, 0, 7, //  97  0001 1111.\n  0, 0, 35, //  98  0001 1100.\n  0, 0, 13, //  99  0001 1011.\n  0, 0, 50, // 100  0001 0110.\n  0, 0, 49, // 101  0001 1010.\n  0, 0, 58, // 102  0000 0100.\n  0, 0, 37, // 103  0000 1110.\n  0, 0, 25, // 104  0000 1111.\n  0, 0, 45, // 105  0000 1010.\n  0, 0, 57, // 106  0000 1000.\n  0, 0, 26, // 107  0000 1101.\n  0, 0, 29, // 108  0000 1011.\n  0, 0, 38, // 109  0000 1100.\n  0, 0, 53, // 110  0000 1001.\n  0, 0, 23, // 111  0001 0001.\n  0, 0, 43, // 112  0001 0000.\n  0, 0, 46, // 113  0000 0110.\n  0, 0, 42, // 114  0001 0100.\n  0, 0, 22, // 115  0001 0101.\n  0, 0, 54, // 116  0000 0101.\n  0, 0, 51, // 117  0001 0010.\n  0, 0, 15, // 118  0001 0011.\n  0, 0, 30, // 119  0000 0111.\n  0, 0, 39, // 120  0000 0001 0.\n  0, 0, 47, // 121  0000 0011 0.\n  0, 0, 55, // 122  0000 0010 1.\n  0, 0, 27, // 123  0000 0001 1.\n  0, 0, 59, // 124  0000 0010 0.\n  0, 0, 31 // 125  0000 0011 1.\n  ]),\n      MOTION = new Int16Array([1 * 3, 2 * 3, 0, //   0\n  4 * 3, 3 * 3, 0, //   1  0\n  0, 0, 0, //   2  1.\n  6 * 3, 5 * 3, 0, //   3  01\n  8 * 3, 7 * 3, 0, //   4  00\n  0, 0, -1, //   5  011.\n  0, 0, 1, //   6  010.\n  9 * 3, 10 * 3, 0, //   7  001\n  12 * 3, 11 * 3, 0, //   8  000\n  0, 0, 2, //   9  0010.\n  0, 0, -2, //  10  0011.\n  14 * 3, 15 * 3, 0, //  11  0001\n  16 * 3, 13 * 3, 0, //  12  0000\n  20 * 3, 18 * 3, 0, //  13  0000 1\n  0, 0, 3, //  14  0001 0.\n  0, 0, -3, //  15  0001 1.\n  17 * 3, 19 * 3, 0, //  16  0000 0\n  -1, 23 * 3, 0, //  17  0000 00\n  27 * 3, 25 * 3, 0, //  18  0000 11\n  26 * 3, 21 * 3, 0, //  19  0000 01\n  24 * 3, 22 * 3, 0, //  20  0000 10\n  32 * 3, 28 * 3, 0, //  21  0000 011\n  29 * 3, 31 * 3, 0, //  22  0000 101\n  -1, 33 * 3, 0, //  23  0000 001\n  36 * 3, 35 * 3, 0, //  24  0000 100\n  0, 0, -4, //  25  0000 111.\n  30 * 3, 34 * 3, 0, //  26  0000 010\n  0, 0, 4, //  27  0000 110.\n  0, 0, -7, //  28  0000 0111.\n  0, 0, 5, //  29  0000 1010.\n  37 * 3, 41 * 3, 0, //  30  0000 0100\n  0, 0, -5, //  31  0000 1011.\n  0, 0, 7, //  32  0000 0110.\n  38 * 3, 40 * 3, 0, //  33  0000 0011\n  42 * 3, 39 * 3, 0, //  34  0000 0101\n  0, 0, -6, //  35  0000 1001.\n  0, 0, 6, //  36  0000 1000.\n  51 * 3, 54 * 3, 0, //  37  0000 0100 0\n  50 * 3, 49 * 3, 0, //  38  0000 0011 0\n  45 * 3, 46 * 3, 0, //  39  0000 0101 1\n  52 * 3, 47 * 3, 0, //  40  0000 0011 1\n  43 * 3, 53 * 3, 0, //  41  0000 0100 1\n  44 * 3, 48 * 3, 0, //  42  0000 0101 0\n  0, 0, 10, //  43  0000 0100 10.\n  0, 0, 9, //  44  0000 0101 00.\n  0, 0, 8, //  45  0000 0101 10.\n  0, 0, -8, //  46  0000 0101 11.\n  57 * 3, 66 * 3, 0, //  47  0000 0011 11\n  0, 0, -9, //  48  0000 0101 01.\n  60 * 3, 64 * 3, 0, //  49  0000 0011 01\n  56 * 3, 61 * 3, 0, //  50  0000 0011 00\n  55 * 3, 62 * 3, 0, //  51  0000 0100 00\n  58 * 3, 63 * 3, 0, //  52  0000 0011 10\n  0, 0, -10, //  53  0000 0100 11.\n  59 * 3, 65 * 3, 0, //  54  0000 0100 01\n  0, 0, 12, //  55  0000 0100 000.\n  0, 0, 16, //  56  0000 0011 000.\n  0, 0, 13, //  57  0000 0011 110.\n  0, 0, 14, //  58  0000 0011 100.\n  0, 0, 11, //  59  0000 0100 010.\n  0, 0, 15, //  60  0000 0011 010.\n  0, 0, -16, //  61  0000 0011 001.\n  0, 0, -12, //  62  0000 0100 001.\n  0, 0, -14, //  63  0000 0011 101.\n  0, 0, -15, //  64  0000 0011 011.\n  0, 0, -11, //  65  0000 0100 011.\n  0, 0, -13 //  66  0000 0011 111.\n  ]),\n      DCT_DC_SIZE_LUMINANCE = new Int8Array([2 * 3, 1 * 3, 0, //   0\n  6 * 3, 5 * 3, 0, //   1  1\n  3 * 3, 4 * 3, 0, //   2  0\n  0, 0, 1, //   3  00.\n  0, 0, 2, //   4  01.\n  9 * 3, 8 * 3, 0, //   5  11\n  7 * 3, 10 * 3, 0, //   6  10\n  0, 0, 0, //   7  100.\n  12 * 3, 11 * 3, 0, //   8  111\n  0, 0, 4, //   9  110.\n  0, 0, 3, //  10  101.\n  13 * 3, 14 * 3, 0, //  11  1111\n  0, 0, 5, //  12  1110.\n  0, 0, 6, //  13  1111 0.\n  16 * 3, 15 * 3, 0, //  14  1111 1\n  17 * 3, -1, 0, //  15  1111 11\n  0, 0, 7, //  16  1111 10.\n  0, 0, 8 //  17  1111 110.\n  ]),\n      DCT_DC_SIZE_CHROMINANCE = new Int8Array([2 * 3, 1 * 3, 0, //   0\n  4 * 3, 3 * 3, 0, //   1  1\n  6 * 3, 5 * 3, 0, //   2  0\n  8 * 3, 7 * 3, 0, //   3  11\n  0, 0, 2, //   4  10.\n  0, 0, 1, //   5  01.\n  0, 0, 0, //   6  00.\n  10 * 3, 9 * 3, 0, //   7  111\n  0, 0, 3, //   8  110.\n  12 * 3, 11 * 3, 0, //   9  1111\n  0, 0, 4, //  10  1110.\n  14 * 3, 13 * 3, 0, //  11  1111 1\n  0, 0, 5, //  12  1111 0.\n  16 * 3, 15 * 3, 0, //  13  1111 11\n  0, 0, 6, //  14  1111 10.\n  17 * 3, -1, 0, //  15  1111 111\n  0, 0, 7, //  16  1111 110.\n  0, 0, 8 //  17  1111 1110.\n  ]),\n      //  dct_coeff bitmap:\n  //    0xff00  run\n  //    0x00ff  level\n  //  Decoded values are unsigned. Sign bit follows in the stream.\n  //  Interpretation of the value 0x0001\n  //    for dc_coeff_first:  run=0, level=1\n  //    for dc_coeff_next:   If the next bit is 1: run=0, level=1\n  //                         If the next bit is 0: end_of_block\n  //  escape decodes as 0xffff.\n  DCT_COEFF = new Int32Array([1 * 3, 2 * 3, 0, //   0\n  4 * 3, 3 * 3, 0, //   1  0\n  0, 0, 0x0001, //   2  1.\n  7 * 3, 8 * 3, 0, //   3  01\n  6 * 3, 5 * 3, 0, //   4  00\n  13 * 3, 9 * 3, 0, //   5  001\n  11 * 3, 10 * 3, 0, //   6  000\n  14 * 3, 12 * 3, 0, //   7  010\n  0, 0, 0x0101, //   8  011.\n  20 * 3, 22 * 3, 0, //   9  0011\n  18 * 3, 21 * 3, 0, //  10  0001\n  16 * 3, 19 * 3, 0, //  11  0000\n  0, 0, 0x0201, //  12  0101.\n  17 * 3, 15 * 3, 0, //  13  0010\n  0, 0, 0x0002, //  14  0100.\n  0, 0, 0x0003, //  15  0010 1.\n  27 * 3, 25 * 3, 0, //  16  0000 0\n  29 * 3, 31 * 3, 0, //  17  0010 0\n  24 * 3, 26 * 3, 0, //  18  0001 0\n  32 * 3, 30 * 3, 0, //  19  0000 1\n  0, 0, 0x0401, //  20  0011 0.\n  23 * 3, 28 * 3, 0, //  21  0001 1\n  0, 0, 0x0301, //  22  0011 1.\n  0, 0, 0x0102, //  23  0001 10.\n  0, 0, 0x0701, //  24  0001 00.\n  0, 0, 0xffff, //  25  0000 01. -- escape\n  0, 0, 0x0601, //  26  0001 01.\n  37 * 3, 36 * 3, 0, //  27  0000 00\n  0, 0, 0x0501, //  28  0001 11.\n  35 * 3, 34 * 3, 0, //  29  0010 00\n  39 * 3, 38 * 3, 0, //  30  0000 11\n  33 * 3, 42 * 3, 0, //  31  0010 01\n  40 * 3, 41 * 3, 0, //  32  0000 10\n  52 * 3, 50 * 3, 0, //  33  0010 010\n  54 * 3, 53 * 3, 0, //  34  0010 001\n  48 * 3, 49 * 3, 0, //  35  0010 000\n  43 * 3, 45 * 3, 0, //  36  0000 001\n  46 * 3, 44 * 3, 0, //  37  0000 000\n  0, 0, 0x0801, //  38  0000 111.\n  0, 0, 0x0004, //  39  0000 110.\n  0, 0, 0x0202, //  40  0000 100.\n  0, 0, 0x0901, //  41  0000 101.\n  51 * 3, 47 * 3, 0, //  42  0010 011\n  55 * 3, 57 * 3, 0, //  43  0000 0010\n  60 * 3, 56 * 3, 0, //  44  0000 0001\n  59 * 3, 58 * 3, 0, //  45  0000 0011\n  61 * 3, 62 * 3, 0, //  46  0000 0000\n  0, 0, 0x0a01, //  47  0010 0111.\n  0, 0, 0x0d01, //  48  0010 0000.\n  0, 0, 0x0006, //  49  0010 0001.\n  0, 0, 0x0103, //  50  0010 0101.\n  0, 0, 0x0005, //  51  0010 0110.\n  0, 0, 0x0302, //  52  0010 0100.\n  0, 0, 0x0b01, //  53  0010 0011.\n  0, 0, 0x0c01, //  54  0010 0010.\n  76 * 3, 75 * 3, 0, //  55  0000 0010 0\n  67 * 3, 70 * 3, 0, //  56  0000 0001 1\n  73 * 3, 71 * 3, 0, //  57  0000 0010 1\n  78 * 3, 74 * 3, 0, //  58  0000 0011 1\n  72 * 3, 77 * 3, 0, //  59  0000 0011 0\n  69 * 3, 64 * 3, 0, //  60  0000 0001 0\n  68 * 3, 63 * 3, 0, //  61  0000 0000 0\n  66 * 3, 65 * 3, 0, //  62  0000 0000 1\n  81 * 3, 87 * 3, 0, //  63  0000 0000 01\n  91 * 3, 80 * 3, 0, //  64  0000 0001 01\n  82 * 3, 79 * 3, 0, //  65  0000 0000 11\n  83 * 3, 86 * 3, 0, //  66  0000 0000 10\n  93 * 3, 92 * 3, 0, //  67  0000 0001 10\n  84 * 3, 85 * 3, 0, //  68  0000 0000 00\n  90 * 3, 94 * 3, 0, //  69  0000 0001 00\n  88 * 3, 89 * 3, 0, //  70  0000 0001 11\n  0, 0, 0x0203, //  71  0000 0010 11.\n  0, 0, 0x0104, //  72  0000 0011 00.\n  0, 0, 0x0007, //  73  0000 0010 10.\n  0, 0, 0x0402, //  74  0000 0011 11.\n  0, 0, 0x0502, //  75  0000 0010 01.\n  0, 0, 0x1001, //  76  0000 0010 00.\n  0, 0, 0x0f01, //  77  0000 0011 01.\n  0, 0, 0x0e01, //  78  0000 0011 10.\n  105 * 3, 107 * 3, 0, //  79  0000 0000 111\n  111 * 3, 114 * 3, 0, //  80  0000 0001 011\n  104 * 3, 97 * 3, 0, //  81  0000 0000 010\n  125 * 3, 119 * 3, 0, //  82  0000 0000 110\n  96 * 3, 98 * 3, 0, //  83  0000 0000 100\n  -1, 123 * 3, 0, //  84  0000 0000 000\n  95 * 3, 101 * 3, 0, //  85  0000 0000 001\n  106 * 3, 121 * 3, 0, //  86  0000 0000 101\n  99 * 3, 102 * 3, 0, //  87  0000 0000 011\n  113 * 3, 103 * 3, 0, //  88  0000 0001 110\n  112 * 3, 116 * 3, 0, //  89  0000 0001 111\n  110 * 3, 100 * 3, 0, //  90  0000 0001 000\n  124 * 3, 115 * 3, 0, //  91  0000 0001 010\n  117 * 3, 122 * 3, 0, //  92  0000 0001 101\n  109 * 3, 118 * 3, 0, //  93  0000 0001 100\n  120 * 3, 108 * 3, 0, //  94  0000 0001 001\n  127 * 3, 136 * 3, 0, //  95  0000 0000 0010\n  139 * 3, 140 * 3, 0, //  96  0000 0000 1000\n  130 * 3, 126 * 3, 0, //  97  0000 0000 0101\n  145 * 3, 146 * 3, 0, //  98  0000 0000 1001\n  128 * 3, 129 * 3, 0, //  99  0000 0000 0110\n  0, 0, 0x0802, // 100  0000 0001 0001.\n  132 * 3, 134 * 3, 0, // 101  0000 0000 0011\n  155 * 3, 154 * 3, 0, // 102  0000 0000 0111\n  0, 0, 0x0008, // 103  0000 0001 1101.\n  137 * 3, 133 * 3, 0, // 104  0000 0000 0100\n  143 * 3, 144 * 3, 0, // 105  0000 0000 1110\n  151 * 3, 138 * 3, 0, // 106  0000 0000 1010\n  142 * 3, 141 * 3, 0, // 107  0000 0000 1111\n  0, 0, 0x000a, // 108  0000 0001 0011.\n  0, 0, 0x0009, // 109  0000 0001 1000.\n  0, 0, 0x000b, // 110  0000 0001 0000.\n  0, 0, 0x1501, // 111  0000 0001 0110.\n  0, 0, 0x0602, // 112  0000 0001 1110.\n  0, 0, 0x0303, // 113  0000 0001 1100.\n  0, 0, 0x1401, // 114  0000 0001 0111.\n  0, 0, 0x0702, // 115  0000 0001 0101.\n  0, 0, 0x1101, // 116  0000 0001 1111.\n  0, 0, 0x1201, // 117  0000 0001 1010.\n  0, 0, 0x1301, // 118  0000 0001 1001.\n  148 * 3, 152 * 3, 0, // 119  0000 0000 1101\n  0, 0, 0x0403, // 120  0000 0001 0010.\n  153 * 3, 150 * 3, 0, // 121  0000 0000 1011\n  0, 0, 0x0105, // 122  0000 0001 1011.\n  131 * 3, 135 * 3, 0, // 123  0000 0000 0001\n  0, 0, 0x0204, // 124  0000 0001 0100.\n  149 * 3, 147 * 3, 0, // 125  0000 0000 1100\n  172 * 3, 173 * 3, 0, // 126  0000 0000 0101 1\n  162 * 3, 158 * 3, 0, // 127  0000 0000 0010 0\n  170 * 3, 161 * 3, 0, // 128  0000 0000 0110 0\n  168 * 3, 166 * 3, 0, // 129  0000 0000 0110 1\n  157 * 3, 179 * 3, 0, // 130  0000 0000 0101 0\n  169 * 3, 167 * 3, 0, // 131  0000 0000 0001 0\n  174 * 3, 171 * 3, 0, // 132  0000 0000 0011 0\n  178 * 3, 177 * 3, 0, // 133  0000 0000 0100 1\n  156 * 3, 159 * 3, 0, // 134  0000 0000 0011 1\n  164 * 3, 165 * 3, 0, // 135  0000 0000 0001 1\n  183 * 3, 182 * 3, 0, // 136  0000 0000 0010 1\n  175 * 3, 176 * 3, 0, // 137  0000 0000 0100 0\n  0, 0, 0x0107, // 138  0000 0000 1010 1.\n  0, 0, 0x0a02, // 139  0000 0000 1000 0.\n  0, 0, 0x0902, // 140  0000 0000 1000 1.\n  0, 0, 0x1601, // 141  0000 0000 1111 1.\n  0, 0, 0x1701, // 142  0000 0000 1111 0.\n  0, 0, 0x1901, // 143  0000 0000 1110 0.\n  0, 0, 0x1801, // 144  0000 0000 1110 1.\n  0, 0, 0x0503, // 145  0000 0000 1001 0.\n  0, 0, 0x0304, // 146  0000 0000 1001 1.\n  0, 0, 0x000d, // 147  0000 0000 1100 1.\n  0, 0, 0x000c, // 148  0000 0000 1101 0.\n  0, 0, 0x000e, // 149  0000 0000 1100 0.\n  0, 0, 0x000f, // 150  0000 0000 1011 1.\n  0, 0, 0x0205, // 151  0000 0000 1010 0.\n  0, 0, 0x1a01, // 152  0000 0000 1101 1.\n  0, 0, 0x0106, // 153  0000 0000 1011 0.\n  180 * 3, 181 * 3, 0, // 154  0000 0000 0111 1\n  160 * 3, 163 * 3, 0, // 155  0000 0000 0111 0\n  196 * 3, 199 * 3, 0, // 156  0000 0000 0011 10\n  0, 0, 0x001b, // 157  0000 0000 0101 00.\n  203 * 3, 185 * 3, 0, // 158  0000 0000 0010 01\n  202 * 3, 201 * 3, 0, // 159  0000 0000 0011 11\n  0, 0, 0x0013, // 160  0000 0000 0111 00.\n  0, 0, 0x0016, // 161  0000 0000 0110 01.\n  197 * 3, 207 * 3, 0, // 162  0000 0000 0010 00\n  0, 0, 0x0012, // 163  0000 0000 0111 01.\n  191 * 3, 192 * 3, 0, // 164  0000 0000 0001 10\n  188 * 3, 190 * 3, 0, // 165  0000 0000 0001 11\n  0, 0, 0x0014, // 166  0000 0000 0110 11.\n  184 * 3, 194 * 3, 0, // 167  0000 0000 0001 01\n  0, 0, 0x0015, // 168  0000 0000 0110 10.\n  186 * 3, 193 * 3, 0, // 169  0000 0000 0001 00\n  0, 0, 0x0017, // 170  0000 0000 0110 00.\n  204 * 3, 198 * 3, 0, // 171  0000 0000 0011 01\n  0, 0, 0x0019, // 172  0000 0000 0101 10.\n  0, 0, 0x0018, // 173  0000 0000 0101 11.\n  200 * 3, 205 * 3, 0, // 174  0000 0000 0011 00\n  0, 0, 0x001f, // 175  0000 0000 0100 00.\n  0, 0, 0x001e, // 176  0000 0000 0100 01.\n  0, 0, 0x001c, // 177  0000 0000 0100 11.\n  0, 0, 0x001d, // 178  0000 0000 0100 10.\n  0, 0, 0x001a, // 179  0000 0000 0101 01.\n  0, 0, 0x0011, // 180  0000 0000 0111 10.\n  0, 0, 0x0010, // 181  0000 0000 0111 11.\n  189 * 3, 206 * 3, 0, // 182  0000 0000 0010 11\n  187 * 3, 195 * 3, 0, // 183  0000 0000 0010 10\n  218 * 3, 211 * 3, 0, // 184  0000 0000 0001 010\n  0, 0, 0x0025, // 185  0000 0000 0010 011.\n  215 * 3, 216 * 3, 0, // 186  0000 0000 0001 000\n  0, 0, 0x0024, // 187  0000 0000 0010 100.\n  210 * 3, 212 * 3, 0, // 188  0000 0000 0001 110\n  0, 0, 0x0022, // 189  0000 0000 0010 110.\n  213 * 3, 209 * 3, 0, // 190  0000 0000 0001 111\n  221 * 3, 222 * 3, 0, // 191  0000 0000 0001 100\n  219 * 3, 208 * 3, 0, // 192  0000 0000 0001 101\n  217 * 3, 214 * 3, 0, // 193  0000 0000 0001 001\n  223 * 3, 220 * 3, 0, // 194  0000 0000 0001 011\n  0, 0, 0x0023, // 195  0000 0000 0010 101.\n  0, 0, 0x010b, // 196  0000 0000 0011 100.\n  0, 0, 0x0028, // 197  0000 0000 0010 000.\n  0, 0, 0x010c, // 198  0000 0000 0011 011.\n  0, 0, 0x010a, // 199  0000 0000 0011 101.\n  0, 0, 0x0020, // 200  0000 0000 0011 000.\n  0, 0, 0x0108, // 201  0000 0000 0011 111.\n  0, 0, 0x0109, // 202  0000 0000 0011 110.\n  0, 0, 0x0026, // 203  0000 0000 0010 010.\n  0, 0, 0x010d, // 204  0000 0000 0011 010.\n  0, 0, 0x010e, // 205  0000 0000 0011 001.\n  0, 0, 0x0021, // 206  0000 0000 0010 111.\n  0, 0, 0x0027, // 207  0000 0000 0010 001.\n  0, 0, 0x1f01, // 208  0000 0000 0001 1011.\n  0, 0, 0x1b01, // 209  0000 0000 0001 1111.\n  0, 0, 0x1e01, // 210  0000 0000 0001 1100.\n  0, 0, 0x1002, // 211  0000 0000 0001 0101.\n  0, 0, 0x1d01, // 212  0000 0000 0001 1101.\n  0, 0, 0x1c01, // 213  0000 0000 0001 1110.\n  0, 0, 0x010f, // 214  0000 0000 0001 0011.\n  0, 0, 0x0112, // 215  0000 0000 0001 0000.\n  0, 0, 0x0111, // 216  0000 0000 0001 0001.\n  0, 0, 0x0110, // 217  0000 0000 0001 0010.\n  0, 0, 0x0603, // 218  0000 0000 0001 0100.\n  0, 0, 0x0b02, // 219  0000 0000 0001 1010.\n  0, 0, 0x0e02, // 220  0000 0000 0001 0111.\n  0, 0, 0x0d02, // 221  0000 0000 0001 1000.\n  0, 0, 0x0c02, // 222  0000 0000 0001 1001.\n  0, 0, 0x0f02 // 223  0000 0000 0001 0110.\n  ]),\n      PICTURE_TYPE_I = 1,\n      PICTURE_TYPE_P = 2,\n      PICTURE_TYPE_B = 3,\n      //PICTURE_TYPE_D = 4,\n  START_SEQUENCE = 0xB3,\n      START_SLICE_FIRST = 0x01,\n      START_SLICE_LAST = 0xAF,\n      START_PICTURE = 0x00,\n      START_EXTENSION = 0xB5,\n      START_USER_DATA = 0xB2,\n      // Shaders for accelerated WebGL YCbCrToRGBA conversion\n  SHADER_FRAGMENT_YCBCRTORGBA = ['precision mediump float;', 'uniform sampler2D YTexture;', 'uniform sampler2D CBTexture;', 'uniform sampler2D CRTexture;', 'varying vec2 texCoord;', 'void main() {', 'float y = texture2D(YTexture, texCoord).r;', 'float cr = texture2D(CBTexture, texCoord).r - 0.5;', 'float cb = texture2D(CRTexture, texCoord).r - 0.5;', 'gl_FragColor = vec4(', 'y + 1.4 * cr,', 'y + -0.343 * cb - 0.711 * cr,', 'y + 1.765 * cb,', '1.0', ');', '}'].join('\\n'),\n      SHADER_FRAGMENT_LOADING = ['precision mediump float;', 'uniform float loaded;', 'varying vec2 texCoord;', 'void main() {', 'float c = ceil(loaded-(1.0-texCoord.y));', 'gl_FragColor = vec4(c,c,c,1);', '}'].join('\\n'),\n      SHADER_VERTEX_IDENTITY = ['attribute vec2 vertex;', 'varying vec2 texCoord;', 'void main() {', 'texCoord = vertex;', 'gl_Position = vec4((vertex * 2.0 - 1.0) * vec2(1, -1), 0.0, 1.0);', '}'].join('\\n');\n  var MACROBLOCK_TYPE_TABLES = [null, MACROBLOCK_TYPE_I, MACROBLOCK_TYPE_P, MACROBLOCK_TYPE_B]; // ----------------------------------------------------------------------------\n  // Bit Reader\n\n  var BitReader = function BitReader(arrayBuffer) {\n    this.bytes = new Uint8Array(arrayBuffer);\n    this.length = this.bytes.length;\n    this.writePos = this.bytes.length;\n    this.index = 0;\n  };\n\n  BitReader.NOT_FOUND = -1;\n\n  BitReader.prototype.findNextMPEGStartCode = function () {\n    for (var i = this.index + 7 >> 3; i < this.writePos; i++) {\n      if (this.bytes[i] === 0x00 && this.bytes[i + 1] === 0x00 && this.bytes[i + 2] === 0x01) {\n        this.index = i + 4 << 3;\n        return this.bytes[i + 3];\n      }\n    }\n\n    this.index = this.writePos << 3;\n    return BitReader.NOT_FOUND;\n  };\n\n  BitReader.prototype.nextBytesAreStartCode = function () {\n    var i = this.index + 7 >> 3;\n    return i >= this.writePos || this.bytes[i] === 0x00 && this.bytes[i + 1] === 0x00 && this.bytes[i + 2] === 0x01;\n  };\n\n  BitReader.prototype.nextBits = function (count) {\n    var byteOffset = this.index >> 3,\n        room = 8 - this.index % 8;\n\n    if (room >= count) {\n      return this.bytes[byteOffset] >> room - count & 0xff >> 8 - count;\n    }\n\n    var leftover = (this.index + count) % 8,\n        // Leftover bits in last byte\n    end = this.index + count - 1 >> 3,\n        value = this.bytes[byteOffset] & 0xff >> 8 - room; // Fill out first byte\n\n    for (byteOffset++; byteOffset < end; byteOffset++) {\n      value <<= 8; // Shift and\n\n      value |= this.bytes[byteOffset]; // Put next byte\n    }\n\n    if (leftover > 0) {\n      value <<= leftover; // Make room for remaining bits\n\n      value |= this.bytes[byteOffset] >> 8 - leftover;\n    } else {\n      value <<= 8;\n      value |= this.bytes[byteOffset];\n    }\n\n    return value;\n  };\n\n  BitReader.prototype.getBits = function (count) {\n    var value = this.nextBits(count);\n    this.index += count;\n    return value;\n  };\n\n  BitReader.prototype.advance = function (count) {\n    return this.index += count;\n  };\n\n  BitReader.prototype.rewind = function (count) {\n    return this.index -= count;\n  };\n})(window);\n\n//# sourceURL=webpack://node_web/./src/client/js/jsmpeg.min.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/client/js/jsmpeg.min.js"]();
/******/ 	
/******/ })()
;
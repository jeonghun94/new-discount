/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/client/js/jsmpeg.min.js":
/*!*************************************!*\
  !*** ./src/client/js/jsmpeg.min.js ***!
  \*************************************/
/***/ (() => {

eval("(function(window){ 'use strict';\r\n\r\nvar jsmpeg = window.jsmpeg = function(url, opts) {\r\n\topts = opts || {};\r\n\tthis.benchmark = !!opts.benchmark;\r\n\tthis.canvas = opts.canvas || document.createElement('canvas');\r\n\tthis.autoplay = !!opts.autoplay;\r\n\tthis.wantsToPlay = this.autoplay;\r\n\tthis.loop = !!opts.loop;\r\n\tthis.seekable = !!opts.seekable;\r\n\tthis.externalLoadCallback = opts.onload || null;\r\n\tthis.externalDecodeCallback = opts.ondecodeframe || null;\r\n\tthis.externalFinishedCallback = opts.onfinished || null;\r\n\r\n\tthis.progressive = !!opts.progressive;\r\n\tthis.progressiveThrottled = !!opts.progressiveThrottled;\r\n\tthis.progressiveChunkSize = opts.progressiveChunkSize || 256 * 1024;\r\n\tthis.progressiveChunkSizeMax = 4 * 1024 * 1024;\r\n\r\n\tthis.customIntraQuantMatrix = new Uint8Array(64);\r\n\tthis.customNonIntraQuantMatrix = new Uint8Array(64);\r\n\tthis.blockData = new Int32Array(64);\r\n\tthis.zeroBlockData = new Int32Array(64);\r\n\tthis.fillArray(this.zeroBlockData, 0);\r\n\r\n\t// Use WebGL for YCbCrToRGBA conversion if possible (much faster)\r\n\tif (!opts.forceCanvas2D && this.initWebGL()) {\r\n\t\tthis.renderFrame = this.renderFrameGL;\r\n\t\tthis.updateLoader = this.updateLoaderGL;\r\n\t}\r\n\telse {\r\n\t\tthis.canvasContext = this.canvas.getContext('2d');\r\n\t\tthis.renderFrame = this.renderFrame2D;\r\n\t\tthis.updateLoader = this.updateLoader2D;\r\n\t}\r\n\r\n\tif (url instanceof WebSocket) {\r\n\t\tthis.client = url;\r\n\t\tthis.client.onopen = this.initSocketClient.bind(this);\r\n\t}\r\n\telse if (this.progressive) {\r\n\t\tthis.beginProgressiveLoad(url);\r\n\t}\r\n\telse {\r\n\t\tthis.load(url);\r\n\t}\r\n};\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Streaming over WebSockets\r\n\r\njsmpeg.prototype.waitForIntraFrame = true;\r\njsmpeg.prototype.socketBufferSize = 512 * 1024; // 512kb each\r\n\r\njsmpeg.prototype.initSocketClient = function() {\r\n\tthis.buffer = new BitReader(new ArrayBuffer(this.socketBufferSize));\r\n\r\n\tthis.nextPictureBuffer = new BitReader(new ArrayBuffer(this.socketBufferSize));\r\n\tthis.nextPictureBuffer.writePos = 0;\r\n\tthis.nextPictureBuffer.chunkBegin = 0;\r\n\tthis.nextPictureBuffer.lastWriteBeforeWrap = 0;\r\n\r\n\tthis.client.binaryType = 'arraybuffer';\r\n\tthis.client.onmessage = this.receiveSocketMessage.bind(this);\r\n};\r\n\r\njsmpeg.prototype.decodeSocketHeader = function(data) {\r\n\t// Custom header sent to all newly connected clients when streaming\r\n\t// over websockets:\r\n\t// struct { char magic[4] = 'jsmp'; unsigned short width, height; };\r\n\tif (\r\n\t\tdata[0] === SOCKET_MAGIC_BYTES.charCodeAt(0) &&\r\n\t\tdata[1] === SOCKET_MAGIC_BYTES.charCodeAt(1) &&\r\n\t\tdata[2] === SOCKET_MAGIC_BYTES.charCodeAt(2) &&\r\n\t\tdata[3] === SOCKET_MAGIC_BYTES.charCodeAt(3)\r\n\t) {\r\n\t\tthis.width = (data[4] * 256 + data[5]);\r\n\t\tthis.height = (data[6] * 256 + data[7]);\r\n\t\tthis.initBuffers();\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.receiveSocketMessage = function(event) {\r\n\tvar messageData = new Uint8Array(event.data);\r\n\r\n\tif (!this.sequenceStarted) {\r\n\t\tthis.decodeSocketHeader(messageData);\r\n\t}\r\n\r\n\tvar current = this.buffer;\r\n\tvar next = this.nextPictureBuffer;\r\n\r\n\tif (next.writePos + messageData.length > next.length) {\r\n\t\tnext.lastWriteBeforeWrap = next.writePos;\r\n\t\tnext.writePos = 0;\r\n\t\tnext.index = 0;\r\n\t}\r\n\r\n\tnext.bytes.set( messageData, next.writePos );\r\n\tnext.writePos += messageData.length;\r\n\r\n\tvar startCode = 0;\r\n\twhile (true) {\r\n\t\tstartCode = next.findNextMPEGStartCode();\r\n\t\tif (\r\n\t\t\tstartCode === BitReader.NOT_FOUND ||\r\n\t\t\t((next.index >> 3) > next.writePos)\r\n\t\t) {\r\n\t\t\t// We reached the end with no picture found yet; move back a few bytes\r\n\t\t\t// in case we are at the beginning of a start code and exit.\r\n\t\t\tnext.index = Math.max((next.writePos-3), 0) << 3;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if (startCode === START_PICTURE) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// If we are still here, we found the next picture start code!\r\n\r\n\r\n\t// Skip picture decoding until we find the first intra frame?\r\n\tif (this.waitForIntraFrame) {\r\n\t\tnext.advance(10); // skip temporalReference\r\n\t\tif (next.getBits(3) === PICTURE_TYPE_I) {\r\n\t\t\tthis.waitForIntraFrame = false;\r\n\t\t\tnext.chunkBegin = (next.index-13) >> 3;\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Last picture hasn't been decoded yet? Decode now but skip output\r\n\t// before scheduling the next one\r\n\tif (!this.currentPictureDecoded) {\r\n\t\tthis.decodePicture(DECODE_SKIP_OUTPUT);\r\n\t}\r\n\r\n\r\n\t// Copy the picture chunk over to 'this.buffer' and schedule decoding.\r\n\tvar chunkEnd = ((next.index) >> 3);\r\n\r\n\tif (chunkEnd > next.chunkBegin) {\r\n\t\t// Just copy the current picture chunk\r\n\t\tcurrent.bytes.set( next.bytes.subarray(next.chunkBegin, chunkEnd) );\r\n\t\tcurrent.writePos = chunkEnd - next.chunkBegin;\r\n\t}\r\n\telse {\r\n\t\t// We wrapped the nextPictureBuffer around, so we have to copy the last part\r\n\t\t// till the end, as well as from 0 to the current writePos\r\n\t\tcurrent.bytes.set( next.bytes.subarray(next.chunkBegin, next.lastWriteBeforeWrap) );\r\n\t\tvar written = next.lastWriteBeforeWrap - next.chunkBegin;\r\n\t\tcurrent.bytes.set( next.bytes.subarray(0, chunkEnd), written );\r\n\t\tcurrent.writePos = chunkEnd + written;\r\n\t}\r\n\r\n\tcurrent.index = 0;\r\n\tnext.chunkBegin = chunkEnd;\r\n\r\n\t// Decode!\r\n\tthis.currentPictureDecoded = false;\r\n\tsetTimeout(function(){\r\n\t\tthis.decodePicture();\r\n\t\tthis.currentPictureDecoded = true;\r\n\t}.bind(this));\r\n};\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Recording from WebSockets\r\n\r\njsmpeg.prototype.isRecording = false;\r\njsmpeg.prototype.recorderWaitForIntraFrame = false;\r\njsmpeg.prototype.recordedFrames = 0;\r\njsmpeg.prototype.recordedSize = 0;\r\njsmpeg.prototype.didStartRecordingCallback = null;\r\n\r\njsmpeg.prototype.recordBuffers = [];\r\n\r\njsmpeg.prototype.canRecord = function(){\r\n\treturn (this.client && this.client.readyState === this.client.OPEN);\r\n};\r\n\r\njsmpeg.prototype.startRecording = function(callback) {\r\n\tif (!this.canRecord()) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Discard old buffers and set for recording\r\n\tthis.discardRecordBuffers();\r\n\tthis.isRecording = true;\r\n\tthis.recorderWaitForIntraFrame = true;\r\n\tthis.didStartRecordingCallback = callback || null;\r\n\r\n\tthis.recordedFrames = 0;\r\n\tthis.recordedSize = 0;\r\n\r\n\t// Fudge a simple Sequence Header for the MPEG file\r\n\r\n\t// 3 bytes width & height, 12 bits each\r\n\tvar wh1 = (this.width >> 4),\r\n\t\twh2 = ((this.width & 0xf) << 4) | (this.height >> 8),\r\n\t\twh3 = (this.height & 0xff);\r\n\r\n\tthis.recordBuffers.push(new Uint8Array([\r\n\t\t0x00, 0x00, 0x01, 0xb3, // Sequence Start Code\r\n\t\twh1, wh2, wh3, // Width & height\r\n\t\t0x13, // aspect ratio & framerate\r\n\t\t0xff, 0xff, 0xe1, 0x58, // Meh. Bitrate and other boring stuff\r\n\t\t0x00, 0x00, 0x01, 0xb8, 0x00, 0x08, 0x00, // GOP\r\n\t\t0x00, 0x00, 0x00, 0x01, 0x00 // First Picture Start Code\r\n\t]));\r\n};\r\n\r\njsmpeg.prototype.recordFrameFromCurrentBuffer = function() {\r\n\tif (!this.isRecording) { return; }\r\n\r\n\tif (this.recorderWaitForIntraFrame) {\r\n\t\t// Not an intra frame? Exit.\r\n\t\tif (this.pictureCodingType !== PICTURE_TYPE_I) { return; }\r\n\r\n\t\t// Start recording!\r\n\t\tthis.recorderWaitForIntraFrame = false;\r\n\t\tif (this.didStartRecordingCallback) {\r\n\t\t\tthis.didStartRecordingCallback( this );\r\n\t\t}\r\n\t}\r\n\r\n\tthis.recordedFrames++;\r\n\tthis.recordedSize += this.buffer.writePos;\r\n\r\n\t// Copy the actual subrange for the current picture into a new Buffer\r\n\tthis.recordBuffers.push(new Uint8Array(this.buffer.bytes.subarray(0, this.buffer.writePos)));\r\n};\r\n\r\njsmpeg.prototype.discardRecordBuffers = function() {\r\n\tthis.recordBuffers = [];\r\n\tthis.recordedFrames = 0;\r\n};\r\n\r\njsmpeg.prototype.stopRecording = function() {\r\n\tvar blob = new Blob(this.recordBuffers, {type: 'video/mpeg'});\r\n\tthis.discardRecordBuffers();\r\n\tthis.isRecording = false;\r\n\treturn blob;\r\n};\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Loading via Ajax\r\n\r\njsmpeg.prototype.intraFrames = [];\r\njsmpeg.prototype.currentFrame = -1;\r\njsmpeg.prototype.currentTime = 0;\r\njsmpeg.prototype.frameCount = 0;\r\njsmpeg.prototype.duration = 0;\r\n\t\r\njsmpeg.prototype.load = function(url) {\r\n\tthis.url = url;\r\n\r\n\tvar request = new XMLHttpRequest();\r\n\tvar that = this;\r\n\trequest.onreadystatechange = function() {\r\n\t\tif (request.readyState == request.DONE && request.status == 200) {\r\n\t\t\tthat.loadCallback(request.response);\r\n\t\t}\r\n\t};\r\n\r\n\trequest.onprogress = this.updateLoader.bind(this);\r\n\trequest.open('GET', url);\r\n\trequest.responseType = \"arraybuffer\";\r\n\trequest.send();\r\n};\r\n\r\njsmpeg.prototype.updateLoader2D = function(ev) {\r\n\tvar \r\n\t\tp = ev.loaded / ev.total,\r\n\t\tw = this.canvas.width,\r\n\t\th = this.canvas.height,\r\n\t\tctx = this.canvasContext;\r\n\r\n\tctx.fillStyle = '#222';\r\n\tctx.fillRect(0, 0, w, h);\r\n\tctx.fillStyle = '#fff';\r\n\tctx.fillRect(0, h - h*p, w, h*p);\r\n};\r\n\r\njsmpeg.prototype.updateLoaderGL = function(ev) {\r\n\tvar gl = this.gl;\r\n\tgl.uniform1f(gl.getUniformLocation(this.loadingProgram, 'loaded'), (ev.loaded / ev.total));\r\n\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n};\r\n\t\r\njsmpeg.prototype.loadCallback = function(file) {\r\n\tthis.buffer = new BitReader(file);\r\n\r\n\tif (this.seekable) {\r\n\t\tthis.collectIntraFrames();\r\n\t\tthis.buffer.index = 0;\r\n\t}\r\n\t\r\n\tthis.findStartCode(START_SEQUENCE);\r\n\tthis.firstSequenceHeader = this.buffer.index;\r\n\tthis.decodeSequenceHeader();\r\n\r\n\t// Calculate the duration. This only works if the video is seekable and we have a frame count\r\n\tthis.duration = this.frameCount / this.pictureRate;\r\n\r\n\t// Load the first frame\r\n\tthis.nextFrame();\r\n\t\r\n\tif (this.autoplay) {\r\n\t\tthis.play();\r\n\t}\r\n\r\n\tif (this.externalLoadCallback) {\r\n\t\tthis.externalLoadCallback(this);\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.collectIntraFrames = function() {\r\n\t// Loop through the whole buffer and collect all intraFrames to build our seek index.\r\n\t// We also keep track of total frame count here\r\n\tvar frame;\r\n\tfor (frame = 0; this.findStartCode(START_PICTURE) !== BitReader.NOT_FOUND; frame++) {\r\n\r\n\t\t// Check if the found picture is an intra frame and remember the position\r\n\t\tthis.buffer.advance(10); // skip temporalReference\r\n\t\tif (this.buffer.getBits(3) === PICTURE_TYPE_I) {\r\n\t\t\t// Remember index 13 bits back, before temporalReference and picture type\r\n\t\t\tthis.intraFrames.push({frame: frame, index: this.buffer.index - 13});\r\n\t\t}\r\n\t}\r\n\r\n\tthis.frameCount = frame;\r\n};\r\n\r\njsmpeg.prototype.seekToFrame = function(seekFrame, seekExact) {\r\n\tif (seekFrame < 0 || seekFrame >= this.frameCount || !this.intraFrames.length) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Find the last intra frame before or equal to seek frame\r\n\tvar target = null;\r\n\tfor (var i = 0; i < this.intraFrames.length && this.intraFrames[i].frame <= seekFrame; i++) {\r\n\t\ttarget = this.intraFrames[i];\r\n\t}\r\n\r\n\tthis.buffer.index = target.index;\r\n\tthis.currentFrame = target.frame-1;\r\n\r\n\t// If we're seeking to the exact frame, we may have to decode some more frames before\r\n\t// the one we want\r\n\tif (seekExact) {\r\n\t\tfor (var frame = target.frame; frame < seekFrame; frame++) {\r\n\t\t\tthis.decodePicture(DECODE_SKIP_OUTPUT);\r\n\t\t\tthis.findStartCode(START_PICTURE);\r\n\t\t}\r\n\t\tthis.currentFrame = seekFrame-1;\r\n\t}\r\n\r\n\t// Decode and display the picture we have seeked to\r\n\tthis.decodePicture();\r\n\treturn true;\r\n};\r\n\r\njsmpeg.prototype.seekToTime = function(time, seekExact) {\r\n\tthis.seekToFrame( (time * this.pictureRate)|0, seekExact );\r\n};\r\n\r\njsmpeg.prototype.play = function() {\r\n\tif (this.playing) { return; }\r\n\tif (this.progressive) {\r\n\t\tthis.wantsToPlay = true;\r\n\t\tthis.attemptToPlay();\r\n\t}\r\n\telse {\r\n\t\tthis._playNow();\r\n\t}\r\n};\r\n\r\njsmpeg.prototype._playNow = function() {\r\n\tthis.targetTime = this.now();\r\n\tthis.playing = true;\r\n\tthis.scheduleNextFrame();\r\n};\r\n\r\njsmpeg.prototype.pause = function() {\r\n\tthis.playing = false;\r\n\tthis.wantsToPlay = false;\r\n};\r\n\r\njsmpeg.prototype.stop = function() {\r\n\tthis.currentFrame = -1;\r\n\tthis.currentTime = 0;\r\n\tthis.wantsToPlay = false;\r\n\tif (this.buffer) {\r\n\t\tthis.buffer.index = this.firstSequenceHeader;\r\n\t}\r\n\tthis.playing = false;\r\n\tif (this.client) {\r\n\t\tthis.client.close();\r\n\t\tthis.client = null;\r\n\t}\r\n};\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Progressive loading via AJAX\r\n\r\njsmpeg.prototype.beginProgressiveLoad = function(url) {\r\n\tthis.url = url;\r\n\t\r\n\tthis.progressiveLoadPositon = 0;\r\n\tthis.fileSize = 0;\r\n\r\n\tvar request = new XMLHttpRequest();\r\n\tvar that = this;\r\n\trequest.onreadystatechange = function() {\r\n\t\tif (request.readyState === request.DONE) {\r\n\t\t\tthat.fileSize = parseInt(request.getResponseHeader(\"Content-Length\"));\r\n\t\t\tthat.buffer = new BitReader(new ArrayBuffer(that.fileSize));\r\n\t\t\tthat.buffer.writePos = 0;\r\n\t\t\tthat.loadNextChunk();\r\n\t\t}\r\n\t};\r\n\trequest.open('HEAD', url);\r\n\trequest.send();\r\n};\r\n\r\njsmpeg.prototype.maybeLoadNextChunk = function() {\r\n\tif (\r\n\t\t!this.chunkIsLoading && \r\n\t\t(this.buffer.index >> 3) > this.nextChunkLoadAt &&\r\n\t\tthis.progressiveLoadFails < 5\r\n\t) {\r\n\t\tthis.loadNextChunk();\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.loadNextChunk = function() {\r\n\tvar that = this;\r\n\tvar start = this.buffer.writePos,\r\n\t\tend = Math.min(this.buffer.writePos + that.progressiveChunkSize-1, this.fileSize-1);\r\n\t\r\n\tif (start >= this.fileSize) {\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tthis.chunkIsLoading = true;\r\n\tthis.chunkLoadStart = Date.now();\r\n\tvar request = new XMLHttpRequest();\r\n\r\n\trequest.onreadystatechange = function() {\t\t\r\n\t\tif (\r\n\t\t\trequest.readyState === request.DONE && \r\n\t\t\trequest.status > 200 && request.status < 300\r\n\t\t) {\r\n\t\t\tthat.progressiveLoadFails = 0;\r\n\t\t\tthat.progressiveLoadCallback(request.response);\r\n\t\t}\r\n\t\telse if (request.readyState === request.DONE) {\r\n\t\t\t// retry\r\n\t\t\tthat.chunkIsLoading = false;\r\n\t\t\tthat.progressiveLoadFails++;\r\n\t\t\tthat.maybeLoadNextChunk();\r\n\t\t}\r\n\t};\r\n\t\r\n\tif (start === 0) {\r\n\t\trequest.onprogress = this.updateLoader.bind(this);\r\n\t}\r\n\r\n\trequest.open('GET', this.url+'?'+start+\"-\"+end);\r\n\trequest.setRequestHeader(\"Range\", \"bytes=\"+start+\"-\"+end);\r\n\trequest.responseType = \"arraybuffer\";\r\n\trequest.send();\r\n};\r\n\r\njsmpeg.prototype.canPlayThrough = false;\r\n\r\njsmpeg.prototype.progressiveLoadCallback = function(data) {\r\n\tthis.chunkIsLoading = false;\r\n\tvar isFirstChunk = (this.buffer.writePos === 0);\r\n\t\r\n\tvar bytes = new Uint8Array(data);\r\n\tthis.buffer.bytes.set(bytes, this.buffer.writePos);\r\n\tthis.buffer.writePos += bytes.length;\r\n\t\r\n\tif (isFirstChunk) {\r\n\t\tthis.findStartCode(START_SEQUENCE);\r\n\t\tthis.firstSequenceHeader = this.buffer.index;\r\n\t\tthis.decodeSequenceHeader();\r\n\t}\r\n\t\t\r\n\tvar loadTime = (Date.now() - this.chunkLoadStart)/1000;\t\r\n\t\r\n\t// Throttled loading and playback did start already? Calculate when \r\n\t// the next chunk needs to be loaded\r\n\tvar playIndex = (this.buffer.index >> 3);\r\n\tvar bytesPerSecondLoaded = bytes.length / loadTime;\r\n\tvar bytesPerSecondPlayed = 0;\r\n\r\n\tif (this.currentTime > 0) {\r\n\t\tbytesPerSecondPlayed = playIndex / this.currentTime;\r\n\t}\r\n\telse {\r\n\t\t// Playback didn't start - we need to count the frames we got and estimate the bytes per second\r\n\t\tvar currentIndex = this.buffer.index;\r\n\t\tthis.buffer.index = (this.buffer.writePos - bytes.length) << 3;\r\n\t\tvar frames;\r\n\t\tfor (frames = 0; this.findStartCode(START_PICTURE) !== BitReader.NOT_FOUND; frames++) {}\r\n\t\tthis.buffer.index = currentIndex;\r\n\t\tbytesPerSecondPlayed = bytes.length/(frames / this.pictureRate);\r\n\t}\r\n\t\r\n\t\r\n\tvar remainingTimeToPlay = (this.buffer.writePos - playIndex) / bytesPerSecondPlayed;\r\n\tvar remainingTimeToLoad = (this.fileSize - this.buffer.writePos) / bytesPerSecondLoaded;\r\n\tvar totalRemainingPlayTime = (this.fileSize-playIndex) / bytesPerSecondPlayed;\r\n\tthis.canPlayThrough = totalRemainingPlayTime > remainingTimeToLoad;\r\n\r\n\t// Do we have a lot more remaining play time than we typically need for loading? \r\n\t// -> Increase the chunk size for the next load\r\n\tif (remainingTimeToPlay > loadTime * 8) {\r\n\t\tthis.progressiveChunkSize = Math.min(this.progressiveChunkSize * 2, this.progressiveChunkSizeMax);\r\n\t}\r\n\t\r\n\t// Start loading at the latest when only one chunk is left to play, but subtract twice as\r\n\t// much bytes as the next chunk will take to load than it will to play\r\n\tif (this.progressiveThrottled && this.canPlayThrough) {\r\n\t\tthis.nextChunkLoadAt = this.buffer.writePos \r\n\t\t\t- this.progressiveChunkSize * 2\r\n\t\t\t- this.progressiveChunkSize * (bytesPerSecondPlayed / bytesPerSecondLoaded) * 4;\r\n\t}\r\n\telse {\r\n\t\tthis.nextChunkLoadAt = 0;\r\n\t}\r\n\r\n\tif (this.buffer.writePos >= this.fileSize) {\r\n\t\t// All loaded. We don't need to schedule another load\r\n\t\tthis.lastFrameIndex = this.buffer.writePos << 3;\r\n\t\tthis.canPlayThrough = true;\r\n\r\n\t\tif (this.seekable) {\r\n\t\t\tvar currentBufferPos = this.buffer.index;\r\n\t\t\tthis.buffer.index = 0;\r\n\t\t\tthis.collectIntraFrames();\r\n\t\t\tthis.buffer.index = currentBufferPos;\r\n\t\t}\r\n\t\tif (this.externalLoadCallback) {\r\n\t\t\tthis.externalLoadCallback(this);\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t \tthis.lastFrameIndex = this.findLastPictureStartCode();\r\n\t \tthis.maybeLoadNextChunk();\r\n\t }\r\n\t\r\n\tthis.attemptToPlay();\r\n};\r\n\r\njsmpeg.prototype.findLastPictureStartCode = function() {\r\n\tvar bufferBytes = this.buffer.bytes;\r\n\tfor (var i = this.buffer.writePos; i > 3; i--) {\r\n\t\tif (\r\n\t\t\tbufferBytes[i] == START_PICTURE &&\r\n\t\t\tbufferBytes[i-1] == 0x01 &&\r\n\t\t\tbufferBytes[i-2] == 0x00 &&\r\n\t\t\tbufferBytes[i-3] == 0x00\t\t\t\r\n\t\t) {\r\n\t\t\treturn (i-3) << 3;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n};\r\n\r\njsmpeg.prototype.attemptToPlay = function() {\r\n\tif (this.playing || !this.wantsToPlay || !this.canPlayThrough) { \r\n\t\treturn;\r\n\t}\r\n\tthis._playNow();\r\n};\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Utilities\r\n\r\njsmpeg.prototype.readCode = function(codeTable) {\r\n\tvar state = 0;\r\n\tdo {\r\n\t\tstate = codeTable[state + this.buffer.getBits(1)];\r\n\t} while (state >= 0 && codeTable[state] !== 0 );\r\n\treturn codeTable[state+2];\r\n};\r\n\r\njsmpeg.prototype.findStartCode = function(code) {\r\n\tvar current = 0;\r\n\twhile (true) {\r\n\t\tcurrent = this.buffer.findNextMPEGStartCode();\r\n\t\tif (current === code || current === BitReader.NOT_FOUND) {\r\n\t\t\treturn current;\r\n\t\t}\r\n\t}\r\n\treturn BitReader.NOT_FOUND;\r\n};\r\n\r\njsmpeg.prototype.fillArray = function(a, value) {\r\n\tfor (var i = 0, length = a.length; i < length; i++) {\r\n\t\ta[i] = value;\r\n\t}\r\n};\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Sequence Layer\r\n\r\njsmpeg.prototype.pictureRate = 30;\r\njsmpeg.prototype.lateTime = 0;\r\njsmpeg.prototype.firstSequenceHeader = 0;\r\njsmpeg.prototype.targetTime = 0;\r\n\r\njsmpeg.prototype.benchmark = false;\r\njsmpeg.prototype.benchFrame = 0;\r\njsmpeg.prototype.benchDecodeTimes = 0;\r\njsmpeg.prototype.benchAvgFrameTime = 0;\r\n\r\njsmpeg.prototype.now = function() {\r\n\treturn window.performance\r\n\t\t? window.performance.now()\r\n\t\t: Date.now();\r\n};\r\n\r\njsmpeg.prototype.nextFrame = function() {\r\n\tif (!this.buffer) { return; }\r\n\r\n\tvar frameStart = this.now();\r\n\twhile(true) {\r\n\t\tvar code = this.buffer.findNextMPEGStartCode();\r\n\t\t\r\n\t\tif (code === START_SEQUENCE) {\r\n\t\t\tthis.decodeSequenceHeader();\r\n\t\t}\r\n\t\telse if (code === START_PICTURE) {\r\n\t\t\tif (this.progressive && this.buffer.index >= this.lastFrameIndex) {\r\n\t\t\t\t// Starved\r\n\t\t\t\tthis.playing = false;\r\n\t\t\t\tthis.maybeLoadNextChunk();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (this.playing) {\r\n\t\t\t\tthis.scheduleNextFrame();\r\n\t\t\t}\r\n\t\t\tthis.decodePicture();\r\n\t\t\tthis.benchDecodeTimes += this.now() - frameStart;\r\n\t\t\treturn this.canvas;\r\n\t\t}\r\n\t\telse if (code === BitReader.NOT_FOUND) {\r\n\t\t\tthis.stop(); // Jump back to the beginning\r\n\r\n\t\t\tif (this.externalFinishedCallback) {\r\n\t\t\t\tthis.externalFinishedCallback(this);\r\n\t\t\t}\r\n\r\n\t\t\t// Only loop if we found a sequence header\r\n\t\t\tif (this.loop && this.sequenceStarted) {\r\n\t\t\t\tthis.play();\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// ignore (GROUP, USER_DATA, EXTENSION, SLICES...)\r\n\t\t}\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.scheduleNextFrame = function() {\r\n\tthis.lateTime = this.now() - this.targetTime;\r\n\tvar wait = Math.max(0, (1000/this.pictureRate) - this.lateTime);\r\n\tthis.targetTime = this.now() + wait;\r\n\r\n\tif (this.benchmark) {\r\n\t\tthis.benchFrame++;\r\n\t\tif (this.benchFrame >= 120) {\r\n\t\t\tthis.benchAvgFrameTime = this.benchDecodeTimes / this.benchFrame;\r\n\t\t\tthis.benchFrame = 0;\r\n\t\t\tthis.benchDecodeTimes = 0;\r\n\t\t\tif (window.console) { console.log('Average time per frame:', this.benchAvgFrameTime, 'ms'); }\r\n\t\t}\r\n\t\tsetTimeout( this.nextFrame.bind(this), 0);\r\n\t}\r\n\tsetTimeout(this.nextFrame.bind(this), Math.max(wait,1));\r\n};\r\n\r\njsmpeg.prototype.decodeSequenceHeader = function() {\r\n\tthis.width = this.buffer.getBits(12);\r\n\tthis.height = this.buffer.getBits(12);\r\n\tthis.buffer.advance(4); // skip pixel aspect ratio\r\n\tthis.pictureRate = PICTURE_RATE[this.buffer.getBits(4)];\r\n\tthis.buffer.advance(18 + 1 + 10 + 1); // skip bitRate, marker, bufferSize and constrained bit\r\n\r\n\tthis.initBuffers();\r\n\r\n\tvar i;\r\n\r\n\tif (this.buffer.getBits(1)) { // load custom intra quant matrix?\r\n\t\tfor (i = 0; i < 64; i++) {\r\n\t\t\tthis.customIntraQuantMatrix[ZIG_ZAG[i]] = this.buffer.getBits(8);\r\n\t\t}\r\n\t\tthis.intraQuantMatrix = this.customIntraQuantMatrix;\r\n\t}\r\n\r\n\tif (this.buffer.getBits(1)) { // load custom non intra quant matrix?\r\n\t\tfor (i = 0; i < 64; i++) {\r\n\t\t\tthis.customNonIntraQuantMatrix[ZIG_ZAG[i]] = this.buffer.getBits(8);\r\n\t\t}\r\n\t\tthis.nonIntraQuantMatrix = this.customNonIntraQuantMatrix;\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.initBuffers = function() {\r\n\tthis.intraQuantMatrix = DEFAULT_INTRA_QUANT_MATRIX;\r\n\tthis.nonIntraQuantMatrix = DEFAULT_NON_INTRA_QUANT_MATRIX;\r\n\r\n\tthis.mbWidth = (this.width + 15) >> 4;\r\n\tthis.mbHeight = (this.height + 15) >> 4;\r\n\tthis.mbSize = this.mbWidth * this.mbHeight;\r\n\r\n\tthis.codedWidth = this.mbWidth << 4;\r\n\tthis.codedHeight = this.mbHeight << 4;\r\n\tthis.codedSize = this.codedWidth * this.codedHeight;\r\n\r\n\tthis.halfWidth = this.mbWidth << 3;\r\n\tthis.halfHeight = this.mbHeight << 3;\r\n\tthis.quarterSize = this.codedSize >> 2;\r\n\r\n\t// Sequence already started? Don't allocate buffers again\r\n\tif (this.sequenceStarted) { return; }\r\n\tthis.sequenceStarted = true;\r\n\r\n\r\n\t// Manually clamp values when writing macroblocks for shitty browsers\r\n\t// that don't support Uint8ClampedArray\r\n\tvar MaybeClampedUint8Array = window.Uint8ClampedArray || window.Uint8Array;\r\n\tif (!window.Uint8ClampedArray) {\r\n\t\tthis.copyBlockToDestination = this.copyBlockToDestinationClamp;\r\n\t\tthis.addBlockToDestination = this.addBlockToDestinationClamp;\r\n\t}\r\n\r\n\t// Allocated buffers and resize the canvas\r\n\tthis.currentY = new MaybeClampedUint8Array(this.codedSize);\r\n\tthis.currentY32 = new Uint32Array(this.currentY.buffer);\r\n\r\n\tthis.currentCr = new MaybeClampedUint8Array(this.codedSize >> 2);\r\n\tthis.currentCr32 = new Uint32Array(this.currentCr.buffer);\r\n\r\n\tthis.currentCb = new MaybeClampedUint8Array(this.codedSize >> 2);\r\n\tthis.currentCb32 = new Uint32Array(this.currentCb.buffer);\r\n\r\n\r\n\tthis.forwardY = new MaybeClampedUint8Array(this.codedSize);\r\n\tthis.forwardY32 = new Uint32Array(this.forwardY.buffer);\r\n\r\n\tthis.forwardCr = new MaybeClampedUint8Array(this.codedSize >> 2);\r\n\tthis.forwardCr32 = new Uint32Array(this.forwardCr.buffer);\r\n\r\n\tthis.forwardCb = new MaybeClampedUint8Array(this.codedSize >> 2);\r\n\tthis.forwardCb32 = new Uint32Array(this.forwardCb.buffer);\r\n\r\n\tthis.canvas.width = this.width;\r\n\tthis.canvas.height = this.height;\r\n\r\n\tif (this.gl) {\r\n\t\tthis.gl.useProgram(this.program);\r\n\t\tthis.gl.viewport(0, 0, this.width, this.height);\r\n\t}\r\n\telse {\r\n\t\tthis.currentRGBA = this.canvasContext.getImageData(0, 0, this.width, this.height);\r\n\t\tthis.fillArray(this.currentRGBA.data, 255);\r\n\t}\r\n};\r\n\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Picture Layer\r\n\r\njsmpeg.prototype.currentY = null;\r\njsmpeg.prototype.currentCr = null;\r\njsmpeg.prototype.currentCb = null;\r\n\r\njsmpeg.prototype.currentRGBA = null;\r\n\r\njsmpeg.prototype.pictureCodingType = 0;\r\n\r\n// Buffers for motion compensation\r\njsmpeg.prototype.forwardY = null;\r\njsmpeg.prototype.forwardCr = null;\r\njsmpeg.prototype.forwardCb = null;\r\n\r\njsmpeg.prototype.fullPelForward = false;\r\njsmpeg.prototype.forwardFCode = 0;\r\njsmpeg.prototype.forwardRSize = 0;\r\njsmpeg.prototype.forwardF = 0;\r\n\r\n\r\njsmpeg.prototype.decodePicture = function(skipOutput) {\r\n\tthis.currentFrame++;\r\n\tthis.currentTime = this.currentFrame / this.pictureRate;\r\n\r\n\tif (this.progressive) {\r\n\t\tthis.maybeLoadNextChunk();\r\n\t}\r\n\r\n\tthis.buffer.advance(10); // skip temporalReference\r\n\tthis.pictureCodingType = this.buffer.getBits(3);\r\n\tthis.buffer.advance(16); // skip vbv_delay\r\n\r\n\t// Skip B and D frames or unknown coding type\r\n\tif (this.pictureCodingType <= 0 || this.pictureCodingType >= PICTURE_TYPE_B) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// full_pel_forward, forward_f_code\r\n\tif (this.pictureCodingType === PICTURE_TYPE_P) {\r\n\t\tthis.fullPelForward = this.buffer.getBits(1);\r\n\t\tthis.forwardFCode = this.buffer.getBits(3);\r\n\t\tif (this.forwardFCode === 0) {\r\n\t\t\t// Ignore picture with zero forward_f_code\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.forwardRSize = this.forwardFCode - 1;\r\n\t\tthis.forwardF = 1 << this.forwardRSize;\r\n\t}\r\n\r\n\tvar code = 0;\r\n\tdo {\r\n\t\tcode = this.buffer.findNextMPEGStartCode();\r\n\t} while (code === START_EXTENSION || code === START_USER_DATA );\r\n\r\n\r\n\twhile (code >= START_SLICE_FIRST && code <= START_SLICE_LAST) {\r\n\t\tthis.decodeSlice( (code & 0x000000FF) );\r\n\t\tcode = this.buffer.findNextMPEGStartCode();\r\n\t}\r\n\r\n\t// We found the next start code; rewind 32bits and let the main loop handle it.\r\n\tthis.buffer.rewind(32);\r\n\r\n\t// Record this frame, if the recorder wants it\r\n\tthis.recordFrameFromCurrentBuffer();\r\n\r\n\r\n\tif (skipOutput !== DECODE_SKIP_OUTPUT) {\r\n\t\tthis.renderFrame();\r\n\r\n\t\tif (this.externalDecodeCallback) {\r\n\t\t\tthis.externalDecodeCallback(this, this.canvas);\r\n\t\t}\r\n\t}\r\n\r\n\t// If this is a reference picutre then rotate the prediction pointers\r\n\tif (this.pictureCodingType === PICTURE_TYPE_I || this.pictureCodingType === PICTURE_TYPE_P) {\r\n\t\tvar\r\n\t\t\ttmpY = this.forwardY,\r\n\t\t\ttmpY32 = this.forwardY32,\r\n\t\t\ttmpCr = this.forwardCr,\r\n\t\t\ttmpCr32 = this.forwardCr32,\r\n\t\t\ttmpCb = this.forwardCb,\r\n\t\t\ttmpCb32 = this.forwardCb32;\r\n\r\n\t\tthis.forwardY = this.currentY;\r\n\t\tthis.forwardY32 = this.currentY32;\r\n\t\tthis.forwardCr = this.currentCr;\r\n\t\tthis.forwardCr32 = this.currentCr32;\r\n\t\tthis.forwardCb = this.currentCb;\r\n\t\tthis.forwardCb32 = this.currentCb32;\r\n\r\n\t\tthis.currentY = tmpY;\r\n\t\tthis.currentY32 = tmpY32;\r\n\t\tthis.currentCr = tmpCr;\r\n\t\tthis.currentCr32 = tmpCr32;\r\n\t\tthis.currentCb = tmpCb;\r\n\t\tthis.currentCb32 = tmpCb32;\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.YCbCrToRGBA = function() {\r\n\tvar pY = this.currentY;\r\n\tvar pCb = this.currentCb;\r\n\tvar pCr = this.currentCr;\r\n\tvar pRGBA = this.currentRGBA.data;\r\n\r\n\t// Chroma values are the same for each block of 4 pixels, so we proccess\r\n\t// 2 lines at a time, 2 neighboring pixels each.\r\n\t// I wish we could use 32bit writes to the RGBA buffer instead of writing\r\n\t// each byte separately, but we need the automatic clamping of the RGBA\r\n\t// buffer.\r\n\r\n\tvar yIndex1 = 0;\r\n\tvar yIndex2 = this.codedWidth;\r\n\tvar yNext2Lines = this.codedWidth + (this.codedWidth - this.width);\r\n\r\n\tvar cIndex = 0;\r\n\tvar cNextLine = this.halfWidth - (this.width >> 1);\r\n\r\n\tvar rgbaIndex1 = 0;\r\n\tvar rgbaIndex2 = this.width * 4;\r\n\tvar rgbaNext2Lines = this.width * 4;\r\n\r\n\tvar cols = this.width >> 1;\r\n\tvar rows = this.height >> 1;\r\n\r\n\tvar cb, cr, r, g, b;\r\n\r\n\tfor (var row = 0; row < rows; row++) {\r\n\t\tfor (var col = 0; col < cols; col++) {\r\n\t\t\tcb = pCb[cIndex];\r\n\t\t\tcr = pCr[cIndex];\r\n\t\t\tcIndex++;\r\n\r\n\t\t\tr = (cr + ((cr * 103) >> 8)) - 179;\r\n\t\t\tg = ((cb * 88) >> 8) - 44 + ((cr * 183) >> 8) - 91;\r\n\t\t\tb = (cb + ((cb * 198) >> 8)) - 227;\r\n\r\n\t\t\t// Line 1\r\n\t\t\tvar y1 = pY[yIndex1++];\r\n\t\t\tvar y2 = pY[yIndex1++];\r\n\t\t\tpRGBA[rgbaIndex1]   = y1 + r;\r\n\t\t\tpRGBA[rgbaIndex1+1] = y1 - g;\r\n\t\t\tpRGBA[rgbaIndex1+2] = y1 + b;\r\n\t\t\tpRGBA[rgbaIndex1+4] = y2 + r;\r\n\t\t\tpRGBA[rgbaIndex1+5] = y2 - g;\r\n\t\t\tpRGBA[rgbaIndex1+6] = y2 + b;\r\n\t\t\trgbaIndex1 += 8;\r\n\r\n\t\t\t// Line 2\r\n\t\t\tvar y3 = pY[yIndex2++];\r\n\t\t\tvar y4 = pY[yIndex2++];\r\n\t\t\tpRGBA[rgbaIndex2]   = y3 + r;\r\n\t\t\tpRGBA[rgbaIndex2+1] = y3 - g;\r\n\t\t\tpRGBA[rgbaIndex2+2] = y3 + b;\r\n\t\t\tpRGBA[rgbaIndex2+4] = y4 + r;\r\n\t\t\tpRGBA[rgbaIndex2+5] = y4 - g;\r\n\t\t\tpRGBA[rgbaIndex2+6] = y4 + b;\r\n\t\t\trgbaIndex2 += 8;\r\n\t\t}\r\n\r\n\t\tyIndex1 += yNext2Lines;\r\n\t\tyIndex2 += yNext2Lines;\r\n\t\trgbaIndex1 += rgbaNext2Lines;\r\n\t\trgbaIndex2 += rgbaNext2Lines;\r\n\t\tcIndex += cNextLine;\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.renderFrame2D = function() {\r\n\tthis.YCbCrToRGBA();\r\n\tthis.canvasContext.putImageData(this.currentRGBA, 0, 0);\r\n};\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Accelerated WebGL YCbCrToRGBA conversion\r\n\r\njsmpeg.prototype.gl = null;\r\njsmpeg.prototype.program = null;\r\njsmpeg.prototype.YTexture = null;\r\njsmpeg.prototype.CBTexture = null;\r\njsmpeg.prototype.CRTexture = null;\r\n\r\njsmpeg.prototype.createTexture = function(index, name) {\r\n\tvar gl = this.gl;\r\n\tvar texture = gl.createTexture();\r\n\r\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\tgl.uniform1i(gl.getUniformLocation(this.program, name), index);\r\n\r\n\treturn texture;\r\n};\r\n\r\njsmpeg.prototype.compileShader = function(type, source) {\r\n\tvar gl = this.gl;\r\n\tvar shader = gl.createShader(type);\r\n\tgl.shaderSource(shader, source);\r\n\tgl.compileShader(shader);\r\n\r\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n\t\tthrow new Error(gl.getShaderInfoLog(shader));\r\n\t}\r\n\r\n\treturn shader;\r\n};\r\n\r\njsmpeg.prototype.initWebGL = function() {\r\n\tvar gl;\r\n\r\n\t// attempt to get a webgl context\r\n\ttry {\r\n\t\tgl = this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (!gl) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// init buffers\r\n\tthis.buffer = gl.createBuffer();\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);\r\n\r\n\t// The main YCbCrToRGBA Shader\r\n\tthis.program = gl.createProgram();\r\n\tgl.attachShader(this.program, this.compileShader(gl.VERTEX_SHADER, SHADER_VERTEX_IDENTITY));\r\n\tgl.attachShader(this.program, this.compileShader(gl.FRAGMENT_SHADER, SHADER_FRAGMENT_YCBCRTORGBA));\r\n\tgl.linkProgram(this.program);\r\n\r\n\tif (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\r\n\t\tthrow new Error(gl.getProgramInfoLog(this.program));\r\n\t}\r\n\r\n\tgl.useProgram(this.program);\r\n\r\n\t// setup textures\r\n\tthis.YTexture = this.createTexture(0, 'YTexture');\r\n\tthis.CBTexture = this.createTexture(1, 'CBTexture');\r\n\tthis.CRTexture = this.createTexture(2, 'CRTexture');\r\n\r\n\tvar vertexAttr = gl.getAttribLocation(this.program, 'vertex');\r\n\tgl.enableVertexAttribArray(vertexAttr);\r\n\tgl.vertexAttribPointer(vertexAttr, 2, gl.FLOAT, false, 0, 0);\r\n\r\n\r\n\t// Shader for the loading screen\r\n\tthis.loadingProgram = gl.createProgram();\r\n\tgl.attachShader(this.loadingProgram, this.compileShader(gl.VERTEX_SHADER, SHADER_VERTEX_IDENTITY));\r\n\tgl.attachShader(this.loadingProgram, this.compileShader(gl.FRAGMENT_SHADER, SHADER_FRAGMENT_LOADING));\r\n\tgl.linkProgram(this.loadingProgram);\r\n\r\n\tgl.useProgram(this.loadingProgram);\r\n\r\n\tvertexAttr = gl.getAttribLocation(this.loadingProgram, 'vertex');\r\n\tgl.enableVertexAttribArray(vertexAttr);\r\n\tgl.vertexAttribPointer(vertexAttr, 2, gl.FLOAT, false, 0, 0);\r\n\r\n\treturn true;\r\n};\r\n\r\njsmpeg.prototype.renderFrameGL = function() {\r\n\tvar gl = this.gl;\r\n\r\n\t// WebGL doesn't like Uint8ClampedArrays, so we have to create a Uint8Array view for\r\n\t// each plane\r\n\tvar uint8Y = new Uint8Array(this.currentY.buffer),\r\n\t\tuint8Cr = new Uint8Array(this.currentCr.buffer),\r\n\t\tuint8Cb = new Uint8Array(this.currentCb.buffer);\r\n\r\n\tgl.activeTexture(gl.TEXTURE0);\r\n\tgl.bindTexture(gl.TEXTURE_2D, this.YTexture);\r\n\r\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, this.codedWidth, this.height, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, uint8Y);\r\n\r\n\tgl.activeTexture(gl.TEXTURE1);\r\n\tgl.bindTexture(gl.TEXTURE_2D, this.CBTexture);\r\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, this.halfWidth, this.height/2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, uint8Cr);\r\n\r\n\tgl.activeTexture(gl.TEXTURE2);\r\n\tgl.bindTexture(gl.TEXTURE_2D, this.CRTexture);\r\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, this.halfWidth, this.height/2, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, uint8Cb);\r\n\r\n\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n};\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Slice Layer\r\n\r\njsmpeg.prototype.quantizerScale = 0;\r\njsmpeg.prototype.sliceBegin = false;\r\n\r\njsmpeg.prototype.decodeSlice = function(slice) {\r\n\tthis.sliceBegin = true;\r\n\tthis.macroblockAddress = (slice - 1) * this.mbWidth - 1;\r\n\r\n\t// Reset motion vectors and DC predictors\r\n\tthis.motionFwH = this.motionFwHPrev = 0;\r\n\tthis.motionFwV = this.motionFwVPrev = 0;\r\n\tthis.dcPredictorY  = 128;\r\n\tthis.dcPredictorCr = 128;\r\n\tthis.dcPredictorCb = 128;\r\n\r\n\tthis.quantizerScale = this.buffer.getBits(5);\r\n\r\n\t// skip extra bits\r\n\twhile (this.buffer.getBits(1)) {\r\n\t\tthis.buffer.advance(8);\r\n\t}\r\n\r\n\tdo {\r\n\t\tthis.decodeMacroblock();\r\n\t\t// We may have to ignore Video Stream Start Codes here (0xE0)!?\r\n\t} while (!this.buffer.nextBytesAreStartCode() );\r\n};\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Macroblock Layer\r\n\r\njsmpeg.prototype.macroblockAddress = 0;\r\njsmpeg.prototype.mbRow = 0;\r\njsmpeg.prototype.mbCol = 0;\r\n\r\njsmpeg.prototype.macroblockType = 0;\r\njsmpeg.prototype.macroblockIntra = false;\r\njsmpeg.prototype.macroblockMotFw = false;\r\n\r\njsmpeg.prototype.motionFwH = 0;\r\njsmpeg.prototype.motionFwV = 0;\r\njsmpeg.prototype.motionFwHPrev = 0;\r\njsmpeg.prototype.motionFwVPrev = 0;\r\n\r\njsmpeg.prototype.decodeMacroblock = function() {\r\n\t// Decode macroblock_address_increment\r\n\tvar\r\n\t\tincrement = 0,\r\n\t\tt = this.readCode(MACROBLOCK_ADDRESS_INCREMENT);\r\n\r\n\twhile (t === 34) {\r\n\t\t// macroblock_stuffing\r\n\t\tt = this.readCode(MACROBLOCK_ADDRESS_INCREMENT);\r\n\t}\r\n\twhile (t === 35) {\r\n\t\t// macroblock_escape\r\n\t\tincrement += 33;\r\n\t\tt = this.readCode(MACROBLOCK_ADDRESS_INCREMENT);\r\n\t}\r\n\tincrement += t;\r\n\r\n\t// Process any skipped macroblocks\r\n\tif (this.sliceBegin) {\r\n\t\t// The first macroblock_address_increment of each slice is relative\r\n\t\t// to beginning of the preverious row, not the preverious macroblock\r\n\t\tthis.sliceBegin = false;\r\n\t\tthis.macroblockAddress += increment;\r\n\t}\r\n\telse {\r\n\t\tif (this.macroblockAddress + increment >= this.mbSize) {\r\n\t\t\t// Illegal (too large) macroblock_address_increment\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (increment > 1) {\r\n\t\t\t// Skipped macroblocks reset DC predictors\r\n\t\t\tthis.dcPredictorY  = 128;\r\n\t\t\tthis.dcPredictorCr = 128;\r\n\t\t\tthis.dcPredictorCb = 128;\r\n\r\n\t\t\t// Skipped macroblocks in P-pictures reset motion vectors\r\n\t\t\tif (this.pictureCodingType === PICTURE_TYPE_P) {\r\n\t\t\t\tthis.motionFwH = this.motionFwHPrev = 0;\r\n\t\t\t\tthis.motionFwV = this.motionFwVPrev = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Predict skipped macroblocks\r\n\t\twhile (increment > 1) {\r\n\t\t\tthis.macroblockAddress++;\r\n\t\t\tthis.mbRow = (this.macroblockAddress / this.mbWidth)|0;\r\n\t\t\tthis.mbCol = this.macroblockAddress % this.mbWidth;\r\n\t\t\tthis.copyMacroblock(this.motionFwH, this.motionFwV, this.forwardY, this.forwardCr, this.forwardCb);\r\n\t\t\tincrement--;\r\n\t\t}\r\n\t\tthis.macroblockAddress++;\r\n\t}\r\n\tthis.mbRow = (this.macroblockAddress / this.mbWidth)|0;\r\n\tthis.mbCol = this.macroblockAddress % this.mbWidth;\r\n\r\n\t// Process the current macroblock\r\n\tthis.macroblockType = this.readCode(MACROBLOCK_TYPE_TABLES[this.pictureCodingType]);\r\n\tthis.macroblockIntra = (this.macroblockType & 0x01);\r\n\tthis.macroblockMotFw = (this.macroblockType & 0x08);\r\n\r\n\t// Quantizer scale\r\n\tif ((this.macroblockType & 0x10) !== 0) {\r\n\t\tthis.quantizerScale = this.buffer.getBits(5);\r\n\t}\r\n\r\n\tif (this.macroblockIntra) {\r\n\t\t// Intra-coded macroblocks reset motion vectors\r\n\t\tthis.motionFwH = this.motionFwHPrev = 0;\r\n\t\tthis.motionFwV = this.motionFwVPrev = 0;\r\n\t}\r\n\telse {\r\n\t\t// Non-intra macroblocks reset DC predictors\r\n\t\tthis.dcPredictorY = 128;\r\n\t\tthis.dcPredictorCr = 128;\r\n\t\tthis.dcPredictorCb = 128;\r\n\r\n\t\tthis.decodeMotionVectors();\r\n\t\tthis.copyMacroblock(this.motionFwH, this.motionFwV, this.forwardY, this.forwardCr, this.forwardCb);\r\n\t}\r\n\r\n\t// Decode blocks\r\n\tvar cbp = ((this.macroblockType & 0x02) !== 0)\r\n\t\t? this.readCode(CODE_BLOCK_PATTERN)\r\n\t\t: (this.macroblockIntra ? 0x3f : 0);\r\n\r\n\tfor (var block = 0, mask = 0x20; block < 6; block++) {\r\n\t\tif ((cbp & mask) !== 0) {\r\n\t\t\tthis.decodeBlock(block);\r\n\t\t}\r\n\t\tmask >>= 1;\r\n\t}\r\n};\r\n\r\n\r\njsmpeg.prototype.decodeMotionVectors = function() {\r\n\tvar code, d, r = 0;\r\n\r\n\t// Forward\r\n\tif (this.macroblockMotFw) {\r\n\t\t// Horizontal forward\r\n\t\tcode = this.readCode(MOTION);\r\n\t\tif ((code !== 0) && (this.forwardF !== 1)) {\r\n\t\t\tr = this.buffer.getBits(this.forwardRSize);\r\n\t\t\td = ((Math.abs(code) - 1) << this.forwardRSize) + r + 1;\r\n\t\t\tif (code < 0) {\r\n\t\t\t\td = -d;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\td = code;\r\n\t\t}\r\n\r\n\t\tthis.motionFwHPrev += d;\r\n\t\tif (this.motionFwHPrev > (this.forwardF << 4) - 1) {\r\n\t\t\tthis.motionFwHPrev -= this.forwardF << 5;\r\n\t\t}\r\n\t\telse if (this.motionFwHPrev < ((-this.forwardF) << 4)) {\r\n\t\t\tthis.motionFwHPrev += this.forwardF << 5;\r\n\t\t}\r\n\r\n\t\tthis.motionFwH = this.motionFwHPrev;\r\n\t\tif (this.fullPelForward) {\r\n\t\t\tthis.motionFwH <<= 1;\r\n\t\t}\r\n\r\n\t\t// Vertical forward\r\n\t\tcode = this.readCode(MOTION);\r\n\t\tif ((code !== 0) && (this.forwardF !== 1)) {\r\n\t\t\tr = this.buffer.getBits(this.forwardRSize);\r\n\t\t\td = ((Math.abs(code) - 1) << this.forwardRSize) + r + 1;\r\n\t\t\tif (code < 0) {\r\n\t\t\t\td = -d;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\td = code;\r\n\t\t}\r\n\r\n\t\tthis.motionFwVPrev += d;\r\n\t\tif (this.motionFwVPrev > (this.forwardF << 4) - 1) {\r\n\t\t\tthis.motionFwVPrev -= this.forwardF << 5;\r\n\t\t}\r\n\t\telse if (this.motionFwVPrev < ((-this.forwardF) << 4)) {\r\n\t\t\tthis.motionFwVPrev += this.forwardF << 5;\r\n\t\t}\r\n\r\n\t\tthis.motionFwV = this.motionFwVPrev;\r\n\t\tif (this.fullPelForward) {\r\n\t\t\tthis.motionFwV <<= 1;\r\n\t\t}\r\n\t}\r\n\telse if (this.pictureCodingType === PICTURE_TYPE_P) {\r\n\t\t// No motion information in P-picture, reset vectors\r\n\t\tthis.motionFwH = this.motionFwHPrev = 0;\r\n\t\tthis.motionFwV = this.motionFwVPrev = 0;\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.copyMacroblock = function(motionH, motionV, sY, sCr, sCb) {\r\n\tvar\r\n\t\twidth, scan,\r\n\t\tH, V, oddH, oddV,\r\n\t\tsrc, dest, last;\r\n\r\n\t// We use 32bit writes here\r\n\tvar dY = this.currentY32;\r\n\tvar dCb = this.currentCb32;\r\n\tvar dCr = this.currentCr32;\r\n\r\n\t// Luminance\r\n\twidth = this.codedWidth;\r\n\tscan = width - 16;\r\n\r\n\tH = motionH >> 1;\r\n\tV = motionV >> 1;\r\n\toddH = (motionH & 1) === 1;\r\n\toddV = (motionV & 1) === 1;\r\n\r\n\tsrc = ((this.mbRow << 4) + V) * width + (this.mbCol << 4) + H;\r\n\tdest = (this.mbRow * width + this.mbCol) << 2;\r\n\tlast = dest + (width << 2);\r\n\r\n\tvar x;\r\n\tvar y1, y2, y;\r\n\tif (oddH) {\r\n\t\tif (oddV) {\r\n\t\t\twhile (dest < last) {\r\n\t\t\t\ty1 = sY[src] + sY[src+width]; src++;\r\n\t\t\t\tfor (x = 0; x < 4; x++) {\r\n\t\t\t\t\ty2 = sY[src] + sY[src+width]; src++;\r\n\t\t\t\t\ty = (((y1 + y2 + 2) >> 2) & 0xff);\r\n\r\n\t\t\t\t\ty1 = sY[src] + sY[src+width]; src++;\r\n\t\t\t\t\ty |= (((y1 + y2 + 2) << 6) & 0xff00);\r\n\r\n\t\t\t\t\ty2 = sY[src] + sY[src+width]; src++;\r\n\t\t\t\t\ty |= (((y1 + y2 + 2) << 14) & 0xff0000);\r\n\r\n\t\t\t\t\ty1 = sY[src] + sY[src+width]; src++;\r\n\t\t\t\t\ty |= (((y1 + y2 + 2) << 22) & 0xff000000);\r\n\r\n\t\t\t\t\tdY[dest++] = y;\r\n\t\t\t\t}\r\n\t\t\t\tdest += scan >> 2; src += scan-1;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\twhile (dest < last) {\r\n\t\t\t\ty1 = sY[src++];\r\n\t\t\t\tfor (x = 0; x < 4; x++) {\r\n\t\t\t\t\ty2 = sY[src++];\r\n\t\t\t\t\ty = (((y1 + y2 + 1) >> 1) & 0xff);\r\n\r\n\t\t\t\t\ty1 = sY[src++];\r\n\t\t\t\t\ty |= (((y1 + y2 + 1) << 7) & 0xff00);\r\n\r\n\t\t\t\t\ty2 = sY[src++];\r\n\t\t\t\t\ty |= (((y1 + y2 + 1) << 15) & 0xff0000);\r\n\r\n\t\t\t\t\ty1 = sY[src++];\r\n\t\t\t\t\ty |= (((y1 + y2 + 1) << 23) & 0xff000000);\r\n\r\n\t\t\t\t\tdY[dest++] = y;\r\n\t\t\t\t}\r\n\t\t\t\tdest += scan >> 2; src += scan-1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tif (oddV) {\r\n\t\t\twhile (dest < last) {\r\n\t\t\t\tfor (x = 0; x < 4; x++) {\r\n\t\t\t\t\ty = (((sY[src] + sY[src+width] + 1) >> 1) & 0xff); src++;\r\n\t\t\t\t\ty |= (((sY[src] + sY[src+width] + 1) << 7) & 0xff00); src++;\r\n\t\t\t\t\ty |= (((sY[src] + sY[src+width] + 1) << 15) & 0xff0000); src++;\r\n\t\t\t\t\ty |= (((sY[src] + sY[src+width] + 1) << 23) & 0xff000000); src++;\r\n\r\n\t\t\t\t\tdY[dest++] = y;\r\n\t\t\t\t}\r\n\t\t\t\tdest += scan >> 2; src += scan;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\twhile (dest < last) {\r\n\t\t\t\tfor (x = 0; x < 4; x++) {\r\n\t\t\t\t\ty = sY[src]; src++;\r\n\t\t\t\t\ty |= sY[src] << 8; src++;\r\n\t\t\t\t\ty |= sY[src] << 16; src++;\r\n\t\t\t\t\ty |= sY[src] << 24; src++;\r\n\r\n\t\t\t\t\tdY[dest++] = y;\r\n\t\t\t\t}\r\n\t\t\t\tdest += scan >> 2; src += scan;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Chrominance\r\n\r\n\twidth = this.halfWidth;\r\n\tscan = width - 8;\r\n\r\n\tH = (motionH/2) >> 1;\r\n\tV = (motionV/2) >> 1;\r\n\toddH = ((motionH/2) & 1) === 1;\r\n\toddV = ((motionV/2) & 1) === 1;\r\n\r\n\tsrc = ((this.mbRow << 3) + V) * width + (this.mbCol << 3) + H;\r\n\tdest = (this.mbRow * width + this.mbCol) << 1;\r\n\tlast = dest + (width << 1);\r\n\r\n\tvar cr1, cr2, cr;\r\n\tvar cb1, cb2, cb;\r\n\tif (oddH) {\r\n\t\tif (oddV) {\r\n\t\t\twhile (dest < last) {\r\n\t\t\t\tcr1 = sCr[src] + sCr[src+width];\r\n\t\t\t\tcb1 = sCb[src] + sCb[src+width];\r\n\t\t\t\tsrc++;\r\n\t\t\t\tfor (x = 0; x < 2; x++) {\r\n\t\t\t\t\tcr2 = sCr[src] + sCr[src+width];\r\n\t\t\t\t\tcb2 = sCb[src] + sCb[src+width]; src++;\r\n\t\t\t\t\tcr = (((cr1 + cr2 + 2) >> 2) & 0xff);\r\n\t\t\t\t\tcb = (((cb1 + cb2 + 2) >> 2) & 0xff);\r\n\r\n\t\t\t\t\tcr1 = sCr[src] + sCr[src+width];\r\n\t\t\t\t\tcb1 = sCb[src] + sCb[src+width]; src++;\r\n\t\t\t\t\tcr |= (((cr1 + cr2 + 2) << 6) & 0xff00);\r\n\t\t\t\t\tcb |= (((cb1 + cb2 + 2) << 6) & 0xff00);\r\n\r\n\t\t\t\t\tcr2 = sCr[src] + sCr[src+width];\r\n\t\t\t\t\tcb2 = sCb[src] + sCb[src+width]; src++;\r\n\t\t\t\t\tcr |= (((cr1 + cr2 + 2) << 14) & 0xff0000);\r\n\t\t\t\t\tcb |= (((cb1 + cb2 + 2) << 14) & 0xff0000);\r\n\r\n\t\t\t\t\tcr1 = sCr[src] + sCr[src+width];\r\n\t\t\t\t\tcb1 = sCb[src] + sCb[src+width]; src++;\r\n\t\t\t\t\tcr |= (((cr1 + cr2 + 2) << 22) & 0xff000000);\r\n\t\t\t\t\tcb |= (((cb1 + cb2 + 2) << 22) & 0xff000000);\r\n\r\n\t\t\t\t\tdCr[dest] = cr;\r\n\t\t\t\t\tdCb[dest] = cb;\r\n\t\t\t\t\tdest++;\r\n\t\t\t\t}\r\n\t\t\t\tdest += scan >> 2; src += scan-1;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\twhile (dest < last) {\r\n\t\t\t\tcr1 = sCr[src];\r\n\t\t\t\tcb1 = sCb[src];\r\n\t\t\t\tsrc++;\r\n\t\t\t\tfor (x = 0; x < 2; x++) {\r\n\t\t\t\t\tcr2 = sCr[src];\r\n\t\t\t\t\tcb2 = sCb[src++];\r\n\t\t\t\t\tcr = (((cr1 + cr2 + 1) >> 1) & 0xff);\r\n\t\t\t\t\tcb = (((cb1 + cb2 + 1) >> 1) & 0xff);\r\n\r\n\t\t\t\t\tcr1 = sCr[src];\r\n\t\t\t\t\tcb1 = sCb[src++];\r\n\t\t\t\t\tcr |= (((cr1 + cr2 + 1) << 7) & 0xff00);\r\n\t\t\t\t\tcb |= (((cb1 + cb2 + 1) << 7) & 0xff00);\r\n\r\n\t\t\t\t\tcr2 = sCr[src];\r\n\t\t\t\t\tcb2 = sCb[src++];\r\n\t\t\t\t\tcr |= (((cr1 + cr2 + 1) << 15) & 0xff0000);\r\n\t\t\t\t\tcb |= (((cb1 + cb2 + 1) << 15) & 0xff0000);\r\n\r\n\t\t\t\t\tcr1 = sCr[src];\r\n\t\t\t\t\tcb1 = sCb[src++];\r\n\t\t\t\t\tcr |= (((cr1 + cr2 + 1) << 23) & 0xff000000);\r\n\t\t\t\t\tcb |= (((cb1 + cb2 + 1) << 23) & 0xff000000);\r\n\r\n\t\t\t\t\tdCr[dest] = cr;\r\n\t\t\t\t\tdCb[dest] = cb;\r\n\t\t\t\t\tdest++;\r\n\t\t\t\t}\r\n\t\t\t\tdest += scan >> 2; src += scan-1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tif (oddV) {\r\n\t\t\twhile (dest < last) {\r\n\t\t\t\tfor (x = 0; x < 2; x++) {\r\n\t\t\t\t\tcr = (((sCr[src] + sCr[src+width] + 1) >> 1) & 0xff);\r\n\t\t\t\t\tcb = (((sCb[src] + sCb[src+width] + 1) >> 1) & 0xff); src++;\r\n\r\n\t\t\t\t\tcr |= (((sCr[src] + sCr[src+width] + 1) << 7) & 0xff00);\r\n\t\t\t\t\tcb |= (((sCb[src] + sCb[src+width] + 1) << 7) & 0xff00); src++;\r\n\r\n\t\t\t\t\tcr |= (((sCr[src] + sCr[src+width] + 1) << 15) & 0xff0000);\r\n\t\t\t\t\tcb |= (((sCb[src] + sCb[src+width] + 1) << 15) & 0xff0000); src++;\r\n\r\n\t\t\t\t\tcr |= (((sCr[src] + sCr[src+width] + 1) << 23) & 0xff000000);\r\n\t\t\t\t\tcb |= (((sCb[src] + sCb[src+width] + 1) << 23) & 0xff000000); src++;\r\n\r\n\t\t\t\t\tdCr[dest] = cr;\r\n\t\t\t\t\tdCb[dest] = cb;\r\n\t\t\t\t\tdest++;\r\n\t\t\t\t}\r\n\t\t\t\tdest += scan >> 2; src += scan;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\twhile (dest < last) {\r\n\t\t\t\tfor (x = 0; x < 2; x++) {\r\n\t\t\t\t\tcr = sCr[src];\r\n\t\t\t\t\tcb = sCb[src]; src++;\r\n\r\n\t\t\t\t\tcr |= sCr[src] << 8;\r\n\t\t\t\t\tcb |= sCb[src] << 8; src++;\r\n\r\n\t\t\t\t\tcr |= sCr[src] << 16;\r\n\t\t\t\t\tcb |= sCb[src] << 16; src++;\r\n\r\n\t\t\t\t\tcr |= sCr[src] << 24;\r\n\t\t\t\t\tcb |= sCb[src] << 24; src++;\r\n\r\n\t\t\t\t\tdCr[dest] = cr;\r\n\t\t\t\t\tdCb[dest] = cb;\r\n\t\t\t\t\tdest++;\r\n\t\t\t\t}\r\n\t\t\t\tdest += scan >> 2; src += scan;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Block layer\r\n\r\n//jsmpeg.prototype.dcPredictorY;\r\n//jsmpeg.prototype.dcPredictorCr;\r\n//jsmpeg.prototype.dcPredictorCb;\r\n\r\njsmpeg.prototype.blockData = null;\r\njsmpeg.prototype.decodeBlock = function(block) {\r\n\r\n\tvar\r\n\t\tn = 0,\r\n\t\tquantMatrix;\r\n\r\n\t// Decode DC coefficient of intra-coded blocks\r\n\tif (this.macroblockIntra) {\r\n\t\tvar\r\n\t\t\tpredictor,\r\n\t\t\tdctSize;\r\n\r\n\t\t// DC prediction\r\n\r\n\t\tif (block < 4) {\r\n\t\t\tpredictor = this.dcPredictorY;\r\n\t\t\tdctSize = this.readCode(DCT_DC_SIZE_LUMINANCE);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tpredictor = (block === 4 ? this.dcPredictorCr : this.dcPredictorCb);\r\n\t\t\tdctSize = this.readCode(DCT_DC_SIZE_CHROMINANCE);\r\n\t\t}\r\n\r\n\t\t// Read DC coeff\r\n\t\tif (dctSize > 0) {\r\n\t\t\tvar differential = this.buffer.getBits(dctSize);\r\n\t\t\tif ((differential & (1 << (dctSize - 1))) !== 0) {\r\n\t\t\t\tthis.blockData[0] = predictor + differential;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.blockData[0] = predictor + ((-1 << dctSize)|(differential+1));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.blockData[0] = predictor;\r\n\t\t}\r\n\r\n\t\t// Save predictor value\r\n\t\tif (block < 4) {\r\n\t\t\tthis.dcPredictorY = this.blockData[0];\r\n\t\t}\r\n\t\telse if (block === 4) {\r\n\t\t\tthis.dcPredictorCr = this.blockData[0];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.dcPredictorCb = this.blockData[0];\r\n\t\t}\r\n\r\n\t\t// Dequantize + premultiply\r\n\t\tthis.blockData[0] <<= (3 + 5);\r\n\r\n\t\tquantMatrix = this.intraQuantMatrix;\r\n\t\tn = 1;\r\n\t}\r\n\telse {\r\n\t\tquantMatrix = this.nonIntraQuantMatrix;\r\n\t}\r\n\r\n\t// Decode AC coefficients (+DC for non-intra)\r\n\tvar level = 0;\r\n\twhile (true) {\r\n\t\tvar\r\n\t\t\trun = 0,\r\n\t\t\tcoeff = this.readCode(DCT_COEFF);\r\n\r\n\t\tif ((coeff === 0x0001) && (n > 0) && (this.buffer.getBits(1) === 0)) {\r\n\t\t\t// end_of_block\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (coeff === 0xffff) {\r\n\t\t\t// escape\r\n\t\t\trun = this.buffer.getBits(6);\r\n\t\t\tlevel = this.buffer.getBits(8);\r\n\t\t\tif (level === 0) {\r\n\t\t\t\tlevel = this.buffer.getBits(8);\r\n\t\t\t}\r\n\t\t\telse if (level === 128) {\r\n\t\t\t\tlevel = this.buffer.getBits(8) - 256;\r\n\t\t\t}\r\n\t\t\telse if (level > 128) {\r\n\t\t\t\tlevel = level - 256;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\trun = coeff >> 8;\r\n\t\t\tlevel = coeff & 0xff;\r\n\t\t\tif (this.buffer.getBits(1)) {\r\n\t\t\t\tlevel = -level;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tn += run;\r\n\t\tvar dezigZagged = ZIG_ZAG[n];\r\n\t\tn++;\r\n\r\n\t\t// Dequantize, oddify, clip\r\n\t\tlevel <<= 1;\r\n\t\tif (!this.macroblockIntra) {\r\n\t\t\tlevel += (level < 0 ? -1 : 1);\r\n\t\t}\r\n\t\tlevel = (level * this.quantizerScale * quantMatrix[dezigZagged]) >> 4;\r\n\t\tif ((level & 1) === 0) {\r\n\t\t\tlevel -= level > 0 ? 1 : -1;\r\n\t\t}\r\n\t\tif (level > 2047) {\r\n\t\t\tlevel = 2047;\r\n\t\t}\r\n\t\telse if (level < -2048) {\r\n\t\t\tlevel = -2048;\r\n\t\t}\r\n\r\n\t\t// Save premultiplied coefficient\r\n\t\tthis.blockData[dezigZagged] = level * PREMULTIPLIER_MATRIX[dezigZagged];\r\n\t}\r\n\r\n\t// Move block to its place\r\n\tvar\r\n\t\tdestArray,\r\n\t\tdestIndex,\r\n\t\tscan;\r\n\r\n\tif (block < 4) {\r\n\t\tdestArray = this.currentY;\r\n\t\tscan = this.codedWidth - 8;\r\n\t\tdestIndex = (this.mbRow * this.codedWidth + this.mbCol) << 4;\r\n\t\tif ((block & 1) !== 0) {\r\n\t\t\tdestIndex += 8;\r\n\t\t}\r\n\t\tif ((block & 2) !== 0) {\r\n\t\t\tdestIndex += this.codedWidth << 3;\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tdestArray = (block === 4) ? this.currentCb : this.currentCr;\r\n\t\tscan = (this.codedWidth >> 1) - 8;\r\n\t\tdestIndex = ((this.mbRow * this.codedWidth) << 2) + (this.mbCol << 3);\r\n\t}\r\n\r\n\tif (this.macroblockIntra) {\r\n\t\t// Overwrite (no prediction)\r\n\t\tif (n === 1) {\r\n\t\t\tthis.copyValueToDestination((this.blockData[0] + 128) >> 8, destArray, destIndex, scan);\r\n\t\t\tthis.blockData[0] = 0;\r\n\t\t} else {\r\n\t\t\tthis.IDCT();\r\n\t\t\tthis.copyBlockToDestination(this.blockData, destArray, destIndex, scan);\r\n\t\t\tthis.blockData.set(this.zeroBlockData);\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\t// Add data to the predicted macroblock\r\n\t\tif (n === 1) {\r\n\t\t\tthis.addValueToDestination((this.blockData[0] + 128) >> 8, destArray, destIndex, scan);\r\n\t\t\tthis.blockData[0] = 0;\r\n\t\t} else {\r\n\t\t\tthis.IDCT();\r\n\t\t\tthis.addBlockToDestination(this.blockData, destArray, destIndex, scan);\r\n\t\t\tthis.blockData.set(this.zeroBlockData);\r\n\t\t}\r\n\t}\r\n\r\n\tn = 0;\r\n};\r\n\r\njsmpeg.prototype.copyBlockToDestination = function(blockData, destArray, destIndex, scan) {\r\n\tfor (var n = 0; n < 64; n += 8, destIndex += scan+8) {\r\n\t\tdestArray[destIndex+0] = blockData[n+0];\r\n\t\tdestArray[destIndex+1] = blockData[n+1];\r\n\t\tdestArray[destIndex+2] = blockData[n+2];\r\n\t\tdestArray[destIndex+3] = blockData[n+3];\r\n\t\tdestArray[destIndex+4] = blockData[n+4];\r\n\t\tdestArray[destIndex+5] = blockData[n+5];\r\n\t\tdestArray[destIndex+6] = blockData[n+6];\r\n\t\tdestArray[destIndex+7] = blockData[n+7];\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.addBlockToDestination = function(blockData, destArray, destIndex, scan) {\r\n\tfor (var n = 0; n < 64; n += 8, destIndex += scan+8) {\r\n\t\tdestArray[destIndex+0] += blockData[n+0];\r\n\t\tdestArray[destIndex+1] += blockData[n+1];\r\n\t\tdestArray[destIndex+2] += blockData[n+2];\r\n\t\tdestArray[destIndex+3] += blockData[n+3];\r\n\t\tdestArray[destIndex+4] += blockData[n+4];\r\n\t\tdestArray[destIndex+5] += blockData[n+5];\r\n\t\tdestArray[destIndex+6] += blockData[n+6];\r\n\t\tdestArray[destIndex+7] += blockData[n+7];\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.copyValueToDestination = function(value, destArray, destIndex, scan) {\r\n\tfor (var n = 0; n < 64; n += 8, destIndex += scan+8) {\r\n\t\tdestArray[destIndex+0] = value;\r\n\t\tdestArray[destIndex+1] = value;\r\n\t\tdestArray[destIndex+2] = value;\r\n\t\tdestArray[destIndex+3] = value;\r\n\t\tdestArray[destIndex+4] = value;\r\n\t\tdestArray[destIndex+5] = value;\r\n\t\tdestArray[destIndex+6] = value;\r\n\t\tdestArray[destIndex+7] = value;\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.addValueToDestination = function(value, destArray, destIndex, scan) {\r\n\tfor (var n = 0; n < 64; n += 8, destIndex += scan+8) {\r\n\t\tdestArray[destIndex+0] += value;\r\n\t\tdestArray[destIndex+1] += value;\r\n\t\tdestArray[destIndex+2] += value;\r\n\t\tdestArray[destIndex+3] += value;\r\n\t\tdestArray[destIndex+4] += value;\r\n\t\tdestArray[destIndex+5] += value;\r\n\t\tdestArray[destIndex+6] += value;\r\n\t\tdestArray[destIndex+7] += value;\r\n\t}\r\n};\r\n\r\n// Clamping version for shitty browsers (IE) that don't support Uint8ClampedArray\r\njsmpeg.prototype.copyBlockToDestinationClamp = function(blockData, destArray, destIndex, scan) {\r\n\tvar n = 0;\r\n\tfor (var i = 0; i < 8; i++) {\r\n\t\tfor (var j = 0; j < 8; j++) {\r\n\t\t\tvar p = blockData[n++];\r\n\t\t\tdestArray[destIndex++] = p > 255 ? 255 : (p < 0 ? 0 : p);\r\n\t\t}\r\n\t\tdestIndex += scan;\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.addBlockToDestinationClamp = function(blockData, destArray, destIndex, scan) {\r\n\tvar n = 0;\r\n\tfor (var i = 0; i < 8; i++) {\r\n\t\tfor (var j = 0; j < 8; j++) {\r\n\t\t\tvar p = blockData[n++] + destArray[destIndex];\r\n\t\t\tdestArray[destIndex++] = p > 255 ? 255 : (p < 0 ? 0 : p);\r\n\t\t}\r\n\t\tdestIndex += scan;\r\n\t}\r\n};\r\n\r\njsmpeg.prototype.IDCT = function() {\r\n\t// See http://vsr.informatik.tu-chemnitz.de/~jan/MPEG/HTML/IDCT.html\r\n\t// for more info.\r\n\r\n\tvar\r\n\t\tb1, b3, b4, b6, b7, tmp1, tmp2, m0,\r\n\t\tx0, x1, x2, x3, x4, y3, y4, y5, y6, y7,\r\n\t\ti,\r\n\t\tblockData = this.blockData;\r\n\r\n\t// Transform columns\r\n\tfor (i = 0; i < 8; ++i) {\r\n\t\tb1 = blockData[4*8+i];\r\n\t\tb3 = blockData[2*8+i] + blockData[6*8+i];\r\n\t\tb4 = blockData[5*8+i] - blockData[3*8+i];\r\n\t\ttmp1 = blockData[1*8+i] + blockData[7*8+i];\r\n\t\ttmp2 = blockData[3*8+i] + blockData[5*8+i];\r\n\t\tb6 = blockData[1*8+i] - blockData[7*8+i];\r\n\t\tb7 = tmp1 + tmp2;\r\n\t\tm0 = blockData[0*8+i];\r\n\t\tx4 = ((b6*473 - b4*196 + 128) >> 8) - b7;\r\n\t\tx0 = x4 - (((tmp1 - tmp2)*362 + 128) >> 8);\r\n\t\tx1 = m0 - b1;\r\n\t\tx2 = (((blockData[2*8+i] - blockData[6*8+i])*362 + 128) >> 8) - b3;\r\n\t\tx3 = m0 + b1;\r\n\t\ty3 = x1 + x2;\r\n\t\ty4 = x3 + b3;\r\n\t\ty5 = x1 - x2;\r\n\t\ty6 = x3 - b3;\r\n\t\ty7 = -x0 - ((b4*473 + b6*196 + 128) >> 8);\r\n\t\tblockData[0*8+i] = b7 + y4;\r\n\t\tblockData[1*8+i] = x4 + y3;\r\n\t\tblockData[2*8+i] = y5 - x0;\r\n\t\tblockData[3*8+i] = y6 - y7;\r\n\t\tblockData[4*8+i] = y6 + y7;\r\n\t\tblockData[5*8+i] = x0 + y5;\r\n\t\tblockData[6*8+i] = y3 - x4;\r\n\t\tblockData[7*8+i] = y4 - b7;\r\n\t}\r\n\r\n\t// Transform rows\r\n\tfor (i = 0; i < 64; i += 8) {\r\n\t\tb1 = blockData[4+i];\r\n\t\tb3 = blockData[2+i] + blockData[6+i];\r\n\t\tb4 = blockData[5+i] - blockData[3+i];\r\n\t\ttmp1 = blockData[1+i] + blockData[7+i];\r\n\t\ttmp2 = blockData[3+i] + blockData[5+i];\r\n\t\tb6 = blockData[1+i] - blockData[7+i];\r\n\t\tb7 = tmp1 + tmp2;\r\n\t\tm0 = blockData[0+i];\r\n\t\tx4 = ((b6*473 - b4*196 + 128) >> 8) - b7;\r\n\t\tx0 = x4 - (((tmp1 - tmp2)*362 + 128) >> 8);\r\n\t\tx1 = m0 - b1;\r\n\t\tx2 = (((blockData[2+i] - blockData[6+i])*362 + 128) >> 8) - b3;\r\n\t\tx3 = m0 + b1;\r\n\t\ty3 = x1 + x2;\r\n\t\ty4 = x3 + b3;\r\n\t\ty5 = x1 - x2;\r\n\t\ty6 = x3 - b3;\r\n\t\ty7 = -x0 - ((b4*473 + b6*196 + 128) >> 8);\r\n\t\tblockData[0+i] = (b7 + y4 + 128) >> 8;\r\n\t\tblockData[1+i] = (x4 + y3 + 128) >> 8;\r\n\t\tblockData[2+i] = (y5 - x0 + 128) >> 8;\r\n\t\tblockData[3+i] = (y6 - y7 + 128) >> 8;\r\n\t\tblockData[4+i] = (y6 + y7 + 128) >> 8;\r\n\t\tblockData[5+i] = (x0 + y5 + 128) >> 8;\r\n\t\tblockData[6+i] = (y3 - x4 + 128) >> 8;\r\n\t\tblockData[7+i] = (y4 - b7 + 128) >> 8;\r\n\t}\r\n};\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// VLC Tables and Constants\r\n\r\nvar\r\n\tSOCKET_MAGIC_BYTES = 'jsmp',\r\n\tDECODE_SKIP_OUTPUT = 1,\r\n\tPICTURE_RATE = [\r\n\t\t0.000, 23.976, 24.000, 25.000, 29.970, 30.000, 50.000, 59.940,\r\n\t\t60.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000\r\n\t],\r\n\tZIG_ZAG = new Uint8Array([\r\n\t\t 0,  1,  8, 16,  9,  2,  3, 10,\r\n\t\t17, 24, 32, 25, 18, 11,  4,  5,\r\n\t\t12, 19, 26, 33, 40, 48, 41, 34,\r\n\t\t27, 20, 13,  6,  7, 14, 21, 28,\r\n\t\t35, 42, 49, 56, 57, 50, 43, 36,\r\n\t\t29, 22, 15, 23, 30, 37, 44, 51,\r\n\t\t58, 59, 52, 45, 38, 31, 39, 46,\r\n\t\t53, 60, 61, 54, 47, 55, 62, 63\r\n\t]),\r\n\tDEFAULT_INTRA_QUANT_MATRIX = new Uint8Array([\r\n\t\t 8, 16, 19, 22, 26, 27, 29, 34,\r\n\t\t16, 16, 22, 24, 27, 29, 34, 37,\r\n\t\t19, 22, 26, 27, 29, 34, 34, 38,\r\n\t\t22, 22, 26, 27, 29, 34, 37, 40,\r\n\t\t22, 26, 27, 29, 32, 35, 40, 48,\r\n\t\t26, 27, 29, 32, 35, 40, 48, 58,\r\n\t\t26, 27, 29, 34, 38, 46, 56, 69,\r\n\t\t27, 29, 35, 38, 46, 56, 69, 83\r\n\t]),\r\n\tDEFAULT_NON_INTRA_QUANT_MATRIX = new Uint8Array([\r\n\t\t16, 16, 16, 16, 16, 16, 16, 16,\r\n\t\t16, 16, 16, 16, 16, 16, 16, 16,\r\n\t\t16, 16, 16, 16, 16, 16, 16, 16,\r\n\t\t16, 16, 16, 16, 16, 16, 16, 16,\r\n\t\t16, 16, 16, 16, 16, 16, 16, 16,\r\n\t\t16, 16, 16, 16, 16, 16, 16, 16,\r\n\t\t16, 16, 16, 16, 16, 16, 16, 16,\r\n\t\t16, 16, 16, 16, 16, 16, 16, 16\r\n\t]),\r\n\r\n\tPREMULTIPLIER_MATRIX = new Uint8Array([\r\n\t\t32, 44, 42, 38, 32, 25, 17,  9,\r\n\t\t44, 62, 58, 52, 44, 35, 24, 12,\r\n\t\t42, 58, 55, 49, 42, 33, 23, 12,\r\n\t\t38, 52, 49, 44, 38, 30, 20, 10,\r\n\t\t32, 44, 42, 38, 32, 25, 17,  9,\r\n\t\t25, 35, 33, 30, 25, 20, 14,  7,\r\n\t\t17, 24, 23, 20, 17, 14,  9,  5,\r\n\t\t 9, 12, 12, 10,  9,  7,  5,  2\r\n\t]),\r\n\r\n\t// MPEG-1 VLC\r\n\r\n\t//  macroblock_stuffing decodes as 34.\r\n\t//  macroblock_escape decodes as 35.\r\n\r\n\tMACROBLOCK_ADDRESS_INCREMENT = new Int16Array([\r\n\t\t 1*3,  2*3,  0, //   0\r\n\t\t 3*3,  4*3,  0, //   1  0\r\n\t\t   0,    0,  1, //   2  1.\r\n\t\t 5*3,  6*3,  0, //   3  00\r\n\t\t 7*3,  8*3,  0, //   4  01\r\n\t\t 9*3, 10*3,  0, //   5  000\r\n\t\t11*3, 12*3,  0, //   6  001\r\n\t\t   0,    0,  3, //   7  010.\r\n\t\t   0,    0,  2, //   8  011.\r\n\t\t13*3, 14*3,  0, //   9  0000\r\n\t\t15*3, 16*3,  0, //  10  0001\r\n\t\t   0,    0,  5, //  11  0010.\r\n\t\t   0,    0,  4, //  12  0011.\r\n\t\t17*3, 18*3,  0, //  13  0000 0\r\n\t\t19*3, 20*3,  0, //  14  0000 1\r\n\t\t   0,    0,  7, //  15  0001 0.\r\n\t\t   0,    0,  6, //  16  0001 1.\r\n\t\t21*3, 22*3,  0, //  17  0000 00\r\n\t\t23*3, 24*3,  0, //  18  0000 01\r\n\t\t25*3, 26*3,  0, //  19  0000 10\r\n\t\t27*3, 28*3,  0, //  20  0000 11\r\n\t\t  -1, 29*3,  0, //  21  0000 000\r\n\t\t  -1, 30*3,  0, //  22  0000 001\r\n\t\t31*3, 32*3,  0, //  23  0000 010\r\n\t\t33*3, 34*3,  0, //  24  0000 011\r\n\t\t35*3, 36*3,  0, //  25  0000 100\r\n\t\t37*3, 38*3,  0, //  26  0000 101\r\n\t\t   0,    0,  9, //  27  0000 110.\r\n\t\t   0,    0,  8, //  28  0000 111.\r\n\t\t39*3, 40*3,  0, //  29  0000 0001\r\n\t\t41*3, 42*3,  0, //  30  0000 0011\r\n\t\t43*3, 44*3,  0, //  31  0000 0100\r\n\t\t45*3, 46*3,  0, //  32  0000 0101\r\n\t\t   0,    0, 15, //  33  0000 0110.\r\n\t\t   0,    0, 14, //  34  0000 0111.\r\n\t\t   0,    0, 13, //  35  0000 1000.\r\n\t\t   0,    0, 12, //  36  0000 1001.\r\n\t\t   0,    0, 11, //  37  0000 1010.\r\n\t\t   0,    0, 10, //  38  0000 1011.\r\n\t\t47*3,   -1,  0, //  39  0000 0001 0\r\n\t\t  -1, 48*3,  0, //  40  0000 0001 1\r\n\t\t49*3, 50*3,  0, //  41  0000 0011 0\r\n\t\t51*3, 52*3,  0, //  42  0000 0011 1\r\n\t\t53*3, 54*3,  0, //  43  0000 0100 0\r\n\t\t55*3, 56*3,  0, //  44  0000 0100 1\r\n\t\t57*3, 58*3,  0, //  45  0000 0101 0\r\n\t\t59*3, 60*3,  0, //  46  0000 0101 1\r\n\t\t61*3,   -1,  0, //  47  0000 0001 00\r\n\t\t  -1, 62*3,  0, //  48  0000 0001 11\r\n\t\t63*3, 64*3,  0, //  49  0000 0011 00\r\n\t\t65*3, 66*3,  0, //  50  0000 0011 01\r\n\t\t67*3, 68*3,  0, //  51  0000 0011 10\r\n\t\t69*3, 70*3,  0, //  52  0000 0011 11\r\n\t\t71*3, 72*3,  0, //  53  0000 0100 00\r\n\t\t73*3, 74*3,  0, //  54  0000 0100 01\r\n\t\t   0,    0, 21, //  55  0000 0100 10.\r\n\t\t   0,    0, 20, //  56  0000 0100 11.\r\n\t\t   0,    0, 19, //  57  0000 0101 00.\r\n\t\t   0,    0, 18, //  58  0000 0101 01.\r\n\t\t   0,    0, 17, //  59  0000 0101 10.\r\n\t\t   0,    0, 16, //  60  0000 0101 11.\r\n\t\t   0,    0, 35, //  61  0000 0001 000. -- macroblock_escape\r\n\t\t   0,    0, 34, //  62  0000 0001 111. -- macroblock_stuffing\r\n\t\t   0,    0, 33, //  63  0000 0011 000.\r\n\t\t   0,    0, 32, //  64  0000 0011 001.\r\n\t\t   0,    0, 31, //  65  0000 0011 010.\r\n\t\t   0,    0, 30, //  66  0000 0011 011.\r\n\t\t   0,    0, 29, //  67  0000 0011 100.\r\n\t\t   0,    0, 28, //  68  0000 0011 101.\r\n\t\t   0,    0, 27, //  69  0000 0011 110.\r\n\t\t   0,    0, 26, //  70  0000 0011 111.\r\n\t\t   0,    0, 25, //  71  0000 0100 000.\r\n\t\t   0,    0, 24, //  72  0000 0100 001.\r\n\t\t   0,    0, 23, //  73  0000 0100 010.\r\n\t\t   0,    0, 22  //  74  0000 0100 011.\r\n\t]),\r\n\r\n\t//  macroblock_type bitmap:\r\n\t//    0x10  macroblock_quant\r\n\t//    0x08  macroblock_motion_forward\r\n\t//    0x04  macroblock_motion_backward\r\n\t//    0x02  macrobkock_pattern\r\n\t//    0x01  macroblock_intra\r\n\t//\r\n\r\n\tMACROBLOCK_TYPE_I = new Int8Array([\r\n\t\t 1*3,  2*3,     0, //   0\r\n\t\t  -1,  3*3,     0, //   1  0\r\n\t\t   0,    0,  0x01, //   2  1.\r\n\t\t   0,    0,  0x11  //   3  01.\r\n\t]),\r\n\r\n\tMACROBLOCK_TYPE_P = new Int8Array([\r\n\t\t 1*3,  2*3,     0, //  0\r\n\t\t 3*3,  4*3,     0, //  1  0\r\n\t\t   0,    0,  0x0a, //  2  1.\r\n\t\t 5*3,  6*3,     0, //  3  00\r\n\t\t   0,    0,  0x02, //  4  01.\r\n\t\t 7*3,  8*3,     0, //  5  000\r\n\t\t   0,    0,  0x08, //  6  001.\r\n\t\t 9*3, 10*3,     0, //  7  0000\r\n\t\t11*3, 12*3,     0, //  8  0001\r\n\t\t  -1, 13*3,     0, //  9  00000\r\n\t\t   0,    0,  0x12, // 10  00001.\r\n\t\t   0,    0,  0x1a, // 11  00010.\r\n\t\t   0,    0,  0x01, // 12  00011.\r\n\t\t   0,    0,  0x11  // 13  000001.\r\n\t]),\r\n\r\n\tMACROBLOCK_TYPE_B = new Int8Array([\r\n\t\t 1*3,  2*3,     0,  //  0\r\n\t\t 3*3,  5*3,     0,  //  1  0\r\n\t\t 4*3,  6*3,     0,  //  2  1\r\n\t\t 8*3,  7*3,     0,  //  3  00\r\n\t\t   0,    0,  0x0c,  //  4  10.\r\n\t\t 9*3, 10*3,     0,  //  5  01\r\n\t\t   0,    0,  0x0e,  //  6  11.\r\n\t\t13*3, 14*3,     0,  //  7  001\r\n\t\t12*3, 11*3,     0,  //  8  000\r\n\t\t   0,    0,  0x04,  //  9  010.\r\n\t\t   0,    0,  0x06,  // 10  011.\r\n\t\t18*3, 16*3,     0,  // 11  0001\r\n\t\t15*3, 17*3,     0,  // 12  0000\r\n\t\t   0,    0,  0x08,  // 13  0010.\r\n\t\t   0,    0,  0x0a,  // 14  0011.\r\n\t\t  -1, 19*3,     0,  // 15  00000\r\n\t\t   0,    0,  0x01,  // 16  00011.\r\n\t\t20*3, 21*3,     0,  // 17  00001\r\n\t\t   0,    0,  0x1e,  // 18  00010.\r\n\t\t   0,    0,  0x11,  // 19  000001.\r\n\t\t   0,    0,  0x16,  // 20  000010.\r\n\t\t   0,    0,  0x1a   // 21  000011.\r\n\t]),\r\n\r\n\tCODE_BLOCK_PATTERN = new Int16Array([\r\n\t\t  2*3,   1*3,   0,  //   0\r\n\t\t  3*3,   6*3,   0,  //   1  1\r\n\t\t  4*3,   5*3,   0,  //   2  0\r\n\t\t  8*3,  11*3,   0,  //   3  10\r\n\t\t 12*3,  13*3,   0,  //   4  00\r\n\t\t  9*3,   7*3,   0,  //   5  01\r\n\t\t 10*3,  14*3,   0,  //   6  11\r\n\t\t 20*3,  19*3,   0,  //   7  011\r\n\t\t 18*3,  16*3,   0,  //   8  100\r\n\t\t 23*3,  17*3,   0,  //   9  010\r\n\t\t 27*3,  25*3,   0,  //  10  110\r\n\t\t 21*3,  28*3,   0,  //  11  101\r\n\t\t 15*3,  22*3,   0,  //  12  000\r\n\t\t 24*3,  26*3,   0,  //  13  001\r\n\t\t    0,     0,  60,  //  14  111.\r\n\t\t 35*3,  40*3,   0,  //  15  0000\r\n\t\t 44*3,  48*3,   0,  //  16  1001\r\n\t\t 38*3,  36*3,   0,  //  17  0101\r\n\t\t 42*3,  47*3,   0,  //  18  1000\r\n\t\t 29*3,  31*3,   0,  //  19  0111\r\n\t\t 39*3,  32*3,   0,  //  20  0110\r\n\t\t    0,     0,  32,  //  21  1010.\r\n\t\t 45*3,  46*3,   0,  //  22  0001\r\n\t\t 33*3,  41*3,   0,  //  23  0100\r\n\t\t 43*3,  34*3,   0,  //  24  0010\r\n\t\t    0,     0,   4,  //  25  1101.\r\n\t\t 30*3,  37*3,   0,  //  26  0011\r\n\t\t    0,     0,   8,  //  27  1100.\r\n\t\t    0,     0,  16,  //  28  1011.\r\n\t\t    0,     0,  44,  //  29  0111 0.\r\n\t\t 50*3,  56*3,   0,  //  30  0011 0\r\n\t\t    0,     0,  28,  //  31  0111 1.\r\n\t\t    0,     0,  52,  //  32  0110 1.\r\n\t\t    0,     0,  62,  //  33  0100 0.\r\n\t\t 61*3,  59*3,   0,  //  34  0010 1\r\n\t\t 52*3,  60*3,   0,  //  35  0000 0\r\n\t\t    0,     0,   1,  //  36  0101 1.\r\n\t\t 55*3,  54*3,   0,  //  37  0011 1\r\n\t\t    0,     0,  61,  //  38  0101 0.\r\n\t\t    0,     0,  56,  //  39  0110 0.\r\n\t\t 57*3,  58*3,   0,  //  40  0000 1\r\n\t\t    0,     0,   2,  //  41  0100 1.\r\n\t\t    0,     0,  40,  //  42  1000 0.\r\n\t\t 51*3,  62*3,   0,  //  43  0010 0\r\n\t\t    0,     0,  48,  //  44  1001 0.\r\n\t\t 64*3,  63*3,   0,  //  45  0001 0\r\n\t\t 49*3,  53*3,   0,  //  46  0001 1\r\n\t\t    0,     0,  20,  //  47  1000 1.\r\n\t\t    0,     0,  12,  //  48  1001 1.\r\n\t\t 80*3,  83*3,   0,  //  49  0001 10\r\n\t\t    0,     0,  63,  //  50  0011 00.\r\n\t\t 77*3,  75*3,   0,  //  51  0010 00\r\n\t\t 65*3,  73*3,   0,  //  52  0000 00\r\n\t\t 84*3,  66*3,   0,  //  53  0001 11\r\n\t\t    0,     0,  24,  //  54  0011 11.\r\n\t\t    0,     0,  36,  //  55  0011 10.\r\n\t\t    0,     0,   3,  //  56  0011 01.\r\n\t\t 69*3,  87*3,   0,  //  57  0000 10\r\n\t\t 81*3,  79*3,   0,  //  58  0000 11\r\n\t\t 68*3,  71*3,   0,  //  59  0010 11\r\n\t\t 70*3,  78*3,   0,  //  60  0000 01\r\n\t\t 67*3,  76*3,   0,  //  61  0010 10\r\n\t\t 72*3,  74*3,   0,  //  62  0010 01\r\n\t\t 86*3,  85*3,   0,  //  63  0001 01\r\n\t\t 88*3,  82*3,   0,  //  64  0001 00\r\n\t\t   -1,  94*3,   0,  //  65  0000 000\r\n\t\t 95*3,  97*3,   0,  //  66  0001 111\r\n\t\t    0,     0,  33,  //  67  0010 100.\r\n\t\t    0,     0,   9,  //  68  0010 110.\r\n\t\t106*3, 110*3,   0,  //  69  0000 100\r\n\t\t102*3, 116*3,   0,  //  70  0000 010\r\n\t\t    0,     0,   5,  //  71  0010 111.\r\n\t\t    0,     0,  10,  //  72  0010 010.\r\n\t\t 93*3,  89*3,   0,  //  73  0000 001\r\n\t\t    0,     0,   6,  //  74  0010 011.\r\n\t\t    0,     0,  18,  //  75  0010 001.\r\n\t\t    0,     0,  17,  //  76  0010 101.\r\n\t\t    0,     0,  34,  //  77  0010 000.\r\n\t\t113*3, 119*3,   0,  //  78  0000 011\r\n\t\t103*3, 104*3,   0,  //  79  0000 111\r\n\t\t 90*3,  92*3,   0,  //  80  0001 100\r\n\t\t109*3, 107*3,   0,  //  81  0000 110\r\n\t\t117*3, 118*3,   0,  //  82  0001 001\r\n\t\t101*3,  99*3,   0,  //  83  0001 101\r\n\t\t 98*3,  96*3,   0,  //  84  0001 110\r\n\t\t100*3,  91*3,   0,  //  85  0001 011\r\n\t\t114*3, 115*3,   0,  //  86  0001 010\r\n\t\t105*3, 108*3,   0,  //  87  0000 101\r\n\t\t112*3, 111*3,   0,  //  88  0001 000\r\n\t\t121*3, 125*3,   0,  //  89  0000 0011\r\n\t\t    0,     0,  41,  //  90  0001 1000.\r\n\t\t    0,     0,  14,  //  91  0001 0111.\r\n\t\t    0,     0,  21,  //  92  0001 1001.\r\n\t\t124*3, 122*3,   0,  //  93  0000 0010\r\n\t\t120*3, 123*3,   0,  //  94  0000 0001\r\n\t\t    0,     0,  11,  //  95  0001 1110.\r\n\t\t    0,     0,  19,  //  96  0001 1101.\r\n\t\t    0,     0,   7,  //  97  0001 1111.\r\n\t\t    0,     0,  35,  //  98  0001 1100.\r\n\t\t    0,     0,  13,  //  99  0001 1011.\r\n\t\t    0,     0,  50,  // 100  0001 0110.\r\n\t\t    0,     0,  49,  // 101  0001 1010.\r\n\t\t    0,     0,  58,  // 102  0000 0100.\r\n\t\t    0,     0,  37,  // 103  0000 1110.\r\n\t\t    0,     0,  25,  // 104  0000 1111.\r\n\t\t    0,     0,  45,  // 105  0000 1010.\r\n\t\t    0,     0,  57,  // 106  0000 1000.\r\n\t\t    0,     0,  26,  // 107  0000 1101.\r\n\t\t    0,     0,  29,  // 108  0000 1011.\r\n\t\t    0,     0,  38,  // 109  0000 1100.\r\n\t\t    0,     0,  53,  // 110  0000 1001.\r\n\t\t    0,     0,  23,  // 111  0001 0001.\r\n\t\t    0,     0,  43,  // 112  0001 0000.\r\n\t\t    0,     0,  46,  // 113  0000 0110.\r\n\t\t    0,     0,  42,  // 114  0001 0100.\r\n\t\t    0,     0,  22,  // 115  0001 0101.\r\n\t\t    0,     0,  54,  // 116  0000 0101.\r\n\t\t    0,     0,  51,  // 117  0001 0010.\r\n\t\t    0,     0,  15,  // 118  0001 0011.\r\n\t\t    0,     0,  30,  // 119  0000 0111.\r\n\t\t    0,     0,  39,  // 120  0000 0001 0.\r\n\t\t    0,     0,  47,  // 121  0000 0011 0.\r\n\t\t    0,     0,  55,  // 122  0000 0010 1.\r\n\t\t    0,     0,  27,  // 123  0000 0001 1.\r\n\t\t    0,     0,  59,  // 124  0000 0010 0.\r\n\t\t    0,     0,  31   // 125  0000 0011 1.\r\n\t]),\r\n\r\n\tMOTION = new Int16Array([\r\n\t\t  1*3,   2*3,   0,  //   0\r\n\t\t  4*3,   3*3,   0,  //   1  0\r\n\t\t    0,     0,   0,  //   2  1.\r\n\t\t  6*3,   5*3,   0,  //   3  01\r\n\t\t  8*3,   7*3,   0,  //   4  00\r\n\t\t    0,     0,  -1,  //   5  011.\r\n\t\t    0,     0,   1,  //   6  010.\r\n\t\t  9*3,  10*3,   0,  //   7  001\r\n\t\t 12*3,  11*3,   0,  //   8  000\r\n\t\t    0,     0,   2,  //   9  0010.\r\n\t\t    0,     0,  -2,  //  10  0011.\r\n\t\t 14*3,  15*3,   0,  //  11  0001\r\n\t\t 16*3,  13*3,   0,  //  12  0000\r\n\t\t 20*3,  18*3,   0,  //  13  0000 1\r\n\t\t    0,     0,   3,  //  14  0001 0.\r\n\t\t    0,     0,  -3,  //  15  0001 1.\r\n\t\t 17*3,  19*3,   0,  //  16  0000 0\r\n\t\t   -1,  23*3,   0,  //  17  0000 00\r\n\t\t 27*3,  25*3,   0,  //  18  0000 11\r\n\t\t 26*3,  21*3,   0,  //  19  0000 01\r\n\t\t 24*3,  22*3,   0,  //  20  0000 10\r\n\t\t 32*3,  28*3,   0,  //  21  0000 011\r\n\t\t 29*3,  31*3,   0,  //  22  0000 101\r\n\t\t   -1,  33*3,   0,  //  23  0000 001\r\n\t\t 36*3,  35*3,   0,  //  24  0000 100\r\n\t\t    0,     0,  -4,  //  25  0000 111.\r\n\t\t 30*3,  34*3,   0,  //  26  0000 010\r\n\t\t    0,     0,   4,  //  27  0000 110.\r\n\t\t    0,     0,  -7,  //  28  0000 0111.\r\n\t\t    0,     0,   5,  //  29  0000 1010.\r\n\t\t 37*3,  41*3,   0,  //  30  0000 0100\r\n\t\t    0,     0,  -5,  //  31  0000 1011.\r\n\t\t    0,     0,   7,  //  32  0000 0110.\r\n\t\t 38*3,  40*3,   0,  //  33  0000 0011\r\n\t\t 42*3,  39*3,   0,  //  34  0000 0101\r\n\t\t    0,     0,  -6,  //  35  0000 1001.\r\n\t\t    0,     0,   6,  //  36  0000 1000.\r\n\t\t 51*3,  54*3,   0,  //  37  0000 0100 0\r\n\t\t 50*3,  49*3,   0,  //  38  0000 0011 0\r\n\t\t 45*3,  46*3,   0,  //  39  0000 0101 1\r\n\t\t 52*3,  47*3,   0,  //  40  0000 0011 1\r\n\t\t 43*3,  53*3,   0,  //  41  0000 0100 1\r\n\t\t 44*3,  48*3,   0,  //  42  0000 0101 0\r\n\t\t    0,     0,  10,  //  43  0000 0100 10.\r\n\t\t    0,     0,   9,  //  44  0000 0101 00.\r\n\t\t    0,     0,   8,  //  45  0000 0101 10.\r\n\t\t    0,     0,  -8,  //  46  0000 0101 11.\r\n\t\t 57*3,  66*3,   0,  //  47  0000 0011 11\r\n\t\t    0,     0,  -9,  //  48  0000 0101 01.\r\n\t\t 60*3,  64*3,   0,  //  49  0000 0011 01\r\n\t\t 56*3,  61*3,   0,  //  50  0000 0011 00\r\n\t\t 55*3,  62*3,   0,  //  51  0000 0100 00\r\n\t\t 58*3,  63*3,   0,  //  52  0000 0011 10\r\n\t\t    0,     0, -10,  //  53  0000 0100 11.\r\n\t\t 59*3,  65*3,   0,  //  54  0000 0100 01\r\n\t\t    0,     0,  12,  //  55  0000 0100 000.\r\n\t\t    0,     0,  16,  //  56  0000 0011 000.\r\n\t\t    0,     0,  13,  //  57  0000 0011 110.\r\n\t\t    0,     0,  14,  //  58  0000 0011 100.\r\n\t\t    0,     0,  11,  //  59  0000 0100 010.\r\n\t\t    0,     0,  15,  //  60  0000 0011 010.\r\n\t\t    0,     0, -16,  //  61  0000 0011 001.\r\n\t\t    0,     0, -12,  //  62  0000 0100 001.\r\n\t\t    0,     0, -14,  //  63  0000 0011 101.\r\n\t\t    0,     0, -15,  //  64  0000 0011 011.\r\n\t\t    0,     0, -11,  //  65  0000 0100 011.\r\n\t\t    0,     0, -13   //  66  0000 0011 111.\r\n\t]),\r\n\r\n\tDCT_DC_SIZE_LUMINANCE = new Int8Array([\r\n\t\t  2*3,   1*3, 0,  //   0\r\n\t\t  6*3,   5*3, 0,  //   1  1\r\n\t\t  3*3,   4*3, 0,  //   2  0\r\n\t\t    0,     0, 1,  //   3  00.\r\n\t\t    0,     0, 2,  //   4  01.\r\n\t\t  9*3,   8*3, 0,  //   5  11\r\n\t\t  7*3,  10*3, 0,  //   6  10\r\n\t\t    0,     0, 0,  //   7  100.\r\n\t\t 12*3,  11*3, 0,  //   8  111\r\n\t\t    0,     0, 4,  //   9  110.\r\n\t\t    0,     0, 3,  //  10  101.\r\n\t\t 13*3,  14*3, 0,  //  11  1111\r\n\t\t    0,     0, 5,  //  12  1110.\r\n\t\t    0,     0, 6,  //  13  1111 0.\r\n\t\t 16*3,  15*3, 0,  //  14  1111 1\r\n\t\t 17*3,    -1, 0,  //  15  1111 11\r\n\t\t    0,     0, 7,  //  16  1111 10.\r\n\t\t    0,     0, 8   //  17  1111 110.\r\n\t]),\r\n\r\n\tDCT_DC_SIZE_CHROMINANCE = new Int8Array([\r\n\t\t  2*3,   1*3, 0,  //   0\r\n\t\t  4*3,   3*3, 0,  //   1  1\r\n\t\t  6*3,   5*3, 0,  //   2  0\r\n\t\t  8*3,   7*3, 0,  //   3  11\r\n\t\t    0,     0, 2,  //   4  10.\r\n\t\t    0,     0, 1,  //   5  01.\r\n\t\t    0,     0, 0,  //   6  00.\r\n\t\t 10*3,   9*3, 0,  //   7  111\r\n\t\t    0,     0, 3,  //   8  110.\r\n\t\t 12*3,  11*3, 0,  //   9  1111\r\n\t\t    0,     0, 4,  //  10  1110.\r\n\t\t 14*3,  13*3, 0,  //  11  1111 1\r\n\t\t    0,     0, 5,  //  12  1111 0.\r\n\t\t 16*3,  15*3, 0,  //  13  1111 11\r\n\t\t    0,     0, 6,  //  14  1111 10.\r\n\t\t 17*3,    -1, 0,  //  15  1111 111\r\n\t\t    0,     0, 7,  //  16  1111 110.\r\n\t\t    0,     0, 8   //  17  1111 1110.\r\n\t]),\r\n\r\n\t//  dct_coeff bitmap:\r\n\t//    0xff00  run\r\n\t//    0x00ff  level\r\n\r\n\t//  Decoded values are unsigned. Sign bit follows in the stream.\r\n\r\n\t//  Interpretation of the value 0x0001\r\n\t//    for dc_coeff_first:  run=0, level=1\r\n\t//    for dc_coeff_next:   If the next bit is 1: run=0, level=1\r\n\t//                         If the next bit is 0: end_of_block\r\n\r\n\t//  escape decodes as 0xffff.\r\n\r\n\tDCT_COEFF = new Int32Array([\r\n\t\t  1*3,   2*3,      0,  //   0\r\n\t\t  4*3,   3*3,      0,  //   1  0\r\n\t\t    0,     0, 0x0001,  //   2  1.\r\n\t\t  7*3,   8*3,      0,  //   3  01\r\n\t\t  6*3,   5*3,      0,  //   4  00\r\n\t\t 13*3,   9*3,      0,  //   5  001\r\n\t\t 11*3,  10*3,      0,  //   6  000\r\n\t\t 14*3,  12*3,      0,  //   7  010\r\n\t\t    0,     0, 0x0101,  //   8  011.\r\n\t\t 20*3,  22*3,      0,  //   9  0011\r\n\t\t 18*3,  21*3,      0,  //  10  0001\r\n\t\t 16*3,  19*3,      0,  //  11  0000\r\n\t\t    0,     0, 0x0201,  //  12  0101.\r\n\t\t 17*3,  15*3,      0,  //  13  0010\r\n\t\t    0,     0, 0x0002,  //  14  0100.\r\n\t\t    0,     0, 0x0003,  //  15  0010 1.\r\n\t\t 27*3,  25*3,      0,  //  16  0000 0\r\n\t\t 29*3,  31*3,      0,  //  17  0010 0\r\n\t\t 24*3,  26*3,      0,  //  18  0001 0\r\n\t\t 32*3,  30*3,      0,  //  19  0000 1\r\n\t\t    0,     0, 0x0401,  //  20  0011 0.\r\n\t\t 23*3,  28*3,      0,  //  21  0001 1\r\n\t\t    0,     0, 0x0301,  //  22  0011 1.\r\n\t\t    0,     0, 0x0102,  //  23  0001 10.\r\n\t\t    0,     0, 0x0701,  //  24  0001 00.\r\n\t\t    0,     0, 0xffff,  //  25  0000 01. -- escape\r\n\t\t    0,     0, 0x0601,  //  26  0001 01.\r\n\t\t 37*3,  36*3,      0,  //  27  0000 00\r\n\t\t    0,     0, 0x0501,  //  28  0001 11.\r\n\t\t 35*3,  34*3,      0,  //  29  0010 00\r\n\t\t 39*3,  38*3,      0,  //  30  0000 11\r\n\t\t 33*3,  42*3,      0,  //  31  0010 01\r\n\t\t 40*3,  41*3,      0,  //  32  0000 10\r\n\t\t 52*3,  50*3,      0,  //  33  0010 010\r\n\t\t 54*3,  53*3,      0,  //  34  0010 001\r\n\t\t 48*3,  49*3,      0,  //  35  0010 000\r\n\t\t 43*3,  45*3,      0,  //  36  0000 001\r\n\t\t 46*3,  44*3,      0,  //  37  0000 000\r\n\t\t    0,     0, 0x0801,  //  38  0000 111.\r\n\t\t    0,     0, 0x0004,  //  39  0000 110.\r\n\t\t    0,     0, 0x0202,  //  40  0000 100.\r\n\t\t    0,     0, 0x0901,  //  41  0000 101.\r\n\t\t 51*3,  47*3,      0,  //  42  0010 011\r\n\t\t 55*3,  57*3,      0,  //  43  0000 0010\r\n\t\t 60*3,  56*3,      0,  //  44  0000 0001\r\n\t\t 59*3,  58*3,      0,  //  45  0000 0011\r\n\t\t 61*3,  62*3,      0,  //  46  0000 0000\r\n\t\t    0,     0, 0x0a01,  //  47  0010 0111.\r\n\t\t    0,     0, 0x0d01,  //  48  0010 0000.\r\n\t\t    0,     0, 0x0006,  //  49  0010 0001.\r\n\t\t    0,     0, 0x0103,  //  50  0010 0101.\r\n\t\t    0,     0, 0x0005,  //  51  0010 0110.\r\n\t\t    0,     0, 0x0302,  //  52  0010 0100.\r\n\t\t    0,     0, 0x0b01,  //  53  0010 0011.\r\n\t\t    0,     0, 0x0c01,  //  54  0010 0010.\r\n\t\t 76*3,  75*3,      0,  //  55  0000 0010 0\r\n\t\t 67*3,  70*3,      0,  //  56  0000 0001 1\r\n\t\t 73*3,  71*3,      0,  //  57  0000 0010 1\r\n\t\t 78*3,  74*3,      0,  //  58  0000 0011 1\r\n\t\t 72*3,  77*3,      0,  //  59  0000 0011 0\r\n\t\t 69*3,  64*3,      0,  //  60  0000 0001 0\r\n\t\t 68*3,  63*3,      0,  //  61  0000 0000 0\r\n\t\t 66*3,  65*3,      0,  //  62  0000 0000 1\r\n\t\t 81*3,  87*3,      0,  //  63  0000 0000 01\r\n\t\t 91*3,  80*3,      0,  //  64  0000 0001 01\r\n\t\t 82*3,  79*3,      0,  //  65  0000 0000 11\r\n\t\t 83*3,  86*3,      0,  //  66  0000 0000 10\r\n\t\t 93*3,  92*3,      0,  //  67  0000 0001 10\r\n\t\t 84*3,  85*3,      0,  //  68  0000 0000 00\r\n\t\t 90*3,  94*3,      0,  //  69  0000 0001 00\r\n\t\t 88*3,  89*3,      0,  //  70  0000 0001 11\r\n\t\t    0,     0, 0x0203,  //  71  0000 0010 11.\r\n\t\t    0,     0, 0x0104,  //  72  0000 0011 00.\r\n\t\t    0,     0, 0x0007,  //  73  0000 0010 10.\r\n\t\t    0,     0, 0x0402,  //  74  0000 0011 11.\r\n\t\t    0,     0, 0x0502,  //  75  0000 0010 01.\r\n\t\t    0,     0, 0x1001,  //  76  0000 0010 00.\r\n\t\t    0,     0, 0x0f01,  //  77  0000 0011 01.\r\n\t\t    0,     0, 0x0e01,  //  78  0000 0011 10.\r\n\t\t105*3, 107*3,      0,  //  79  0000 0000 111\r\n\t\t111*3, 114*3,      0,  //  80  0000 0001 011\r\n\t\t104*3,  97*3,      0,  //  81  0000 0000 010\r\n\t\t125*3, 119*3,      0,  //  82  0000 0000 110\r\n\t\t 96*3,  98*3,      0,  //  83  0000 0000 100\r\n\t\t   -1, 123*3,      0,  //  84  0000 0000 000\r\n\t\t 95*3, 101*3,      0,  //  85  0000 0000 001\r\n\t\t106*3, 121*3,      0,  //  86  0000 0000 101\r\n\t\t 99*3, 102*3,      0,  //  87  0000 0000 011\r\n\t\t113*3, 103*3,      0,  //  88  0000 0001 110\r\n\t\t112*3, 116*3,      0,  //  89  0000 0001 111\r\n\t\t110*3, 100*3,      0,  //  90  0000 0001 000\r\n\t\t124*3, 115*3,      0,  //  91  0000 0001 010\r\n\t\t117*3, 122*3,      0,  //  92  0000 0001 101\r\n\t\t109*3, 118*3,      0,  //  93  0000 0001 100\r\n\t\t120*3, 108*3,      0,  //  94  0000 0001 001\r\n\t\t127*3, 136*3,      0,  //  95  0000 0000 0010\r\n\t\t139*3, 140*3,      0,  //  96  0000 0000 1000\r\n\t\t130*3, 126*3,      0,  //  97  0000 0000 0101\r\n\t\t145*3, 146*3,      0,  //  98  0000 0000 1001\r\n\t\t128*3, 129*3,      0,  //  99  0000 0000 0110\r\n\t\t    0,     0, 0x0802,  // 100  0000 0001 0001.\r\n\t\t132*3, 134*3,      0,  // 101  0000 0000 0011\r\n\t\t155*3, 154*3,      0,  // 102  0000 0000 0111\r\n\t\t    0,     0, 0x0008,  // 103  0000 0001 1101.\r\n\t\t137*3, 133*3,      0,  // 104  0000 0000 0100\r\n\t\t143*3, 144*3,      0,  // 105  0000 0000 1110\r\n\t\t151*3, 138*3,      0,  // 106  0000 0000 1010\r\n\t\t142*3, 141*3,      0,  // 107  0000 0000 1111\r\n\t\t    0,     0, 0x000a,  // 108  0000 0001 0011.\r\n\t\t    0,     0, 0x0009,  // 109  0000 0001 1000.\r\n\t\t    0,     0, 0x000b,  // 110  0000 0001 0000.\r\n\t\t    0,     0, 0x1501,  // 111  0000 0001 0110.\r\n\t\t    0,     0, 0x0602,  // 112  0000 0001 1110.\r\n\t\t    0,     0, 0x0303,  // 113  0000 0001 1100.\r\n\t\t    0,     0, 0x1401,  // 114  0000 0001 0111.\r\n\t\t    0,     0, 0x0702,  // 115  0000 0001 0101.\r\n\t\t    0,     0, 0x1101,  // 116  0000 0001 1111.\r\n\t\t    0,     0, 0x1201,  // 117  0000 0001 1010.\r\n\t\t    0,     0, 0x1301,  // 118  0000 0001 1001.\r\n\t\t148*3, 152*3,      0,  // 119  0000 0000 1101\r\n\t\t    0,     0, 0x0403,  // 120  0000 0001 0010.\r\n\t\t153*3, 150*3,      0,  // 121  0000 0000 1011\r\n\t\t    0,     0, 0x0105,  // 122  0000 0001 1011.\r\n\t\t131*3, 135*3,      0,  // 123  0000 0000 0001\r\n\t\t    0,     0, 0x0204,  // 124  0000 0001 0100.\r\n\t\t149*3, 147*3,      0,  // 125  0000 0000 1100\r\n\t\t172*3, 173*3,      0,  // 126  0000 0000 0101 1\r\n\t\t162*3, 158*3,      0,  // 127  0000 0000 0010 0\r\n\t\t170*3, 161*3,      0,  // 128  0000 0000 0110 0\r\n\t\t168*3, 166*3,      0,  // 129  0000 0000 0110 1\r\n\t\t157*3, 179*3,      0,  // 130  0000 0000 0101 0\r\n\t\t169*3, 167*3,      0,  // 131  0000 0000 0001 0\r\n\t\t174*3, 171*3,      0,  // 132  0000 0000 0011 0\r\n\t\t178*3, 177*3,      0,  // 133  0000 0000 0100 1\r\n\t\t156*3, 159*3,      0,  // 134  0000 0000 0011 1\r\n\t\t164*3, 165*3,      0,  // 135  0000 0000 0001 1\r\n\t\t183*3, 182*3,      0,  // 136  0000 0000 0010 1\r\n\t\t175*3, 176*3,      0,  // 137  0000 0000 0100 0\r\n\t\t    0,     0, 0x0107,  // 138  0000 0000 1010 1.\r\n\t\t    0,     0, 0x0a02,  // 139  0000 0000 1000 0.\r\n\t\t    0,     0, 0x0902,  // 140  0000 0000 1000 1.\r\n\t\t    0,     0, 0x1601,  // 141  0000 0000 1111 1.\r\n\t\t    0,     0, 0x1701,  // 142  0000 0000 1111 0.\r\n\t\t    0,     0, 0x1901,  // 143  0000 0000 1110 0.\r\n\t\t    0,     0, 0x1801,  // 144  0000 0000 1110 1.\r\n\t\t    0,     0, 0x0503,  // 145  0000 0000 1001 0.\r\n\t\t    0,     0, 0x0304,  // 146  0000 0000 1001 1.\r\n\t\t    0,     0, 0x000d,  // 147  0000 0000 1100 1.\r\n\t\t    0,     0, 0x000c,  // 148  0000 0000 1101 0.\r\n\t\t    0,     0, 0x000e,  // 149  0000 0000 1100 0.\r\n\t\t    0,     0, 0x000f,  // 150  0000 0000 1011 1.\r\n\t\t    0,     0, 0x0205,  // 151  0000 0000 1010 0.\r\n\t\t    0,     0, 0x1a01,  // 152  0000 0000 1101 1.\r\n\t\t    0,     0, 0x0106,  // 153  0000 0000 1011 0.\r\n\t\t180*3, 181*3,      0,  // 154  0000 0000 0111 1\r\n\t\t160*3, 163*3,      0,  // 155  0000 0000 0111 0\r\n\t\t196*3, 199*3,      0,  // 156  0000 0000 0011 10\r\n\t\t    0,     0, 0x001b,  // 157  0000 0000 0101 00.\r\n\t\t203*3, 185*3,      0,  // 158  0000 0000 0010 01\r\n\t\t202*3, 201*3,      0,  // 159  0000 0000 0011 11\r\n\t\t    0,     0, 0x0013,  // 160  0000 0000 0111 00.\r\n\t\t    0,     0, 0x0016,  // 161  0000 0000 0110 01.\r\n\t\t197*3, 207*3,      0,  // 162  0000 0000 0010 00\r\n\t\t    0,     0, 0x0012,  // 163  0000 0000 0111 01.\r\n\t\t191*3, 192*3,      0,  // 164  0000 0000 0001 10\r\n\t\t188*3, 190*3,      0,  // 165  0000 0000 0001 11\r\n\t\t    0,     0, 0x0014,  // 166  0000 0000 0110 11.\r\n\t\t184*3, 194*3,      0,  // 167  0000 0000 0001 01\r\n\t\t    0,     0, 0x0015,  // 168  0000 0000 0110 10.\r\n\t\t186*3, 193*3,      0,  // 169  0000 0000 0001 00\r\n\t\t    0,     0, 0x0017,  // 170  0000 0000 0110 00.\r\n\t\t204*3, 198*3,      0,  // 171  0000 0000 0011 01\r\n\t\t    0,     0, 0x0019,  // 172  0000 0000 0101 10.\r\n\t\t    0,     0, 0x0018,  // 173  0000 0000 0101 11.\r\n\t\t200*3, 205*3,      0,  // 174  0000 0000 0011 00\r\n\t\t    0,     0, 0x001f,  // 175  0000 0000 0100 00.\r\n\t\t    0,     0, 0x001e,  // 176  0000 0000 0100 01.\r\n\t\t    0,     0, 0x001c,  // 177  0000 0000 0100 11.\r\n\t\t    0,     0, 0x001d,  // 178  0000 0000 0100 10.\r\n\t\t    0,     0, 0x001a,  // 179  0000 0000 0101 01.\r\n\t\t    0,     0, 0x0011,  // 180  0000 0000 0111 10.\r\n\t\t    0,     0, 0x0010,  // 181  0000 0000 0111 11.\r\n\t\t189*3, 206*3,      0,  // 182  0000 0000 0010 11\r\n\t\t187*3, 195*3,      0,  // 183  0000 0000 0010 10\r\n\t\t218*3, 211*3,      0,  // 184  0000 0000 0001 010\r\n\t\t    0,     0, 0x0025,  // 185  0000 0000 0010 011.\r\n\t\t215*3, 216*3,      0,  // 186  0000 0000 0001 000\r\n\t\t    0,     0, 0x0024,  // 187  0000 0000 0010 100.\r\n\t\t210*3, 212*3,      0,  // 188  0000 0000 0001 110\r\n\t\t    0,     0, 0x0022,  // 189  0000 0000 0010 110.\r\n\t\t213*3, 209*3,      0,  // 190  0000 0000 0001 111\r\n\t\t221*3, 222*3,      0,  // 191  0000 0000 0001 100\r\n\t\t219*3, 208*3,      0,  // 192  0000 0000 0001 101\r\n\t\t217*3, 214*3,      0,  // 193  0000 0000 0001 001\r\n\t\t223*3, 220*3,      0,  // 194  0000 0000 0001 011\r\n\t\t    0,     0, 0x0023,  // 195  0000 0000 0010 101.\r\n\t\t    0,     0, 0x010b,  // 196  0000 0000 0011 100.\r\n\t\t    0,     0, 0x0028,  // 197  0000 0000 0010 000.\r\n\t\t    0,     0, 0x010c,  // 198  0000 0000 0011 011.\r\n\t\t    0,     0, 0x010a,  // 199  0000 0000 0011 101.\r\n\t\t    0,     0, 0x0020,  // 200  0000 0000 0011 000.\r\n\t\t    0,     0, 0x0108,  // 201  0000 0000 0011 111.\r\n\t\t    0,     0, 0x0109,  // 202  0000 0000 0011 110.\r\n\t\t    0,     0, 0x0026,  // 203  0000 0000 0010 010.\r\n\t\t    0,     0, 0x010d,  // 204  0000 0000 0011 010.\r\n\t\t    0,     0, 0x010e,  // 205  0000 0000 0011 001.\r\n\t\t    0,     0, 0x0021,  // 206  0000 0000 0010 111.\r\n\t\t    0,     0, 0x0027,  // 207  0000 0000 0010 001.\r\n\t\t    0,     0, 0x1f01,  // 208  0000 0000 0001 1011.\r\n\t\t    0,     0, 0x1b01,  // 209  0000 0000 0001 1111.\r\n\t\t    0,     0, 0x1e01,  // 210  0000 0000 0001 1100.\r\n\t\t    0,     0, 0x1002,  // 211  0000 0000 0001 0101.\r\n\t\t    0,     0, 0x1d01,  // 212  0000 0000 0001 1101.\r\n\t\t    0,     0, 0x1c01,  // 213  0000 0000 0001 1110.\r\n\t\t    0,     0, 0x010f,  // 214  0000 0000 0001 0011.\r\n\t\t    0,     0, 0x0112,  // 215  0000 0000 0001 0000.\r\n\t\t    0,     0, 0x0111,  // 216  0000 0000 0001 0001.\r\n\t\t    0,     0, 0x0110,  // 217  0000 0000 0001 0010.\r\n\t\t    0,     0, 0x0603,  // 218  0000 0000 0001 0100.\r\n\t\t    0,     0, 0x0b02,  // 219  0000 0000 0001 1010.\r\n\t\t    0,     0, 0x0e02,  // 220  0000 0000 0001 0111.\r\n\t\t    0,     0, 0x0d02,  // 221  0000 0000 0001 1000.\r\n\t\t    0,     0, 0x0c02,  // 222  0000 0000 0001 1001.\r\n\t\t    0,     0, 0x0f02   // 223  0000 0000 0001 0110.\r\n\t]),\r\n\r\n\tPICTURE_TYPE_I = 1,\r\n\tPICTURE_TYPE_P = 2,\r\n\tPICTURE_TYPE_B = 3,\r\n\t//PICTURE_TYPE_D = 4,\r\n\r\n\tSTART_SEQUENCE = 0xB3,\r\n\tSTART_SLICE_FIRST = 0x01,\r\n\tSTART_SLICE_LAST = 0xAF,\r\n\tSTART_PICTURE = 0x00,\r\n\tSTART_EXTENSION = 0xB5,\r\n\tSTART_USER_DATA = 0xB2,\r\n\r\n\t// Shaders for accelerated WebGL YCbCrToRGBA conversion\r\n\tSHADER_FRAGMENT_YCBCRTORGBA = [\r\n\t\t'precision mediump float;',\r\n\t\t'uniform sampler2D YTexture;',\r\n\t\t'uniform sampler2D CBTexture;',\r\n\t\t'uniform sampler2D CRTexture;',\r\n\t\t'varying vec2 texCoord;',\r\n\r\n\t\t'void main() {',\r\n\t\t\t'float y = texture2D(YTexture, texCoord).r;',\r\n\t\t\t'float cr = texture2D(CBTexture, texCoord).r - 0.5;',\r\n\t\t\t'float cb = texture2D(CRTexture, texCoord).r - 0.5;',\r\n\r\n\t\t\t'gl_FragColor = vec4(',\r\n\t\t\t\t'y + 1.4 * cr,',\r\n\t\t\t\t'y + -0.343 * cb - 0.711 * cr,',\r\n\t\t\t\t'y + 1.765 * cb,',\r\n\t\t\t\t'1.0',\r\n\t\t\t');',\r\n\t\t'}'\r\n\t].join('\\n'),\r\n\r\n\tSHADER_FRAGMENT_LOADING = [\r\n\t\t'precision mediump float;',\r\n\t\t'uniform float loaded;',\r\n\t\t'varying vec2 texCoord;',\r\n\r\n\t\t'void main() {',\r\n\t\t\t'float c = ceil(loaded-(1.0-texCoord.y));',\r\n\t\t\t'gl_FragColor = vec4(c,c,c,1);',\r\n\t\t'}'\r\n\t].join('\\n'),\r\n\r\n\tSHADER_VERTEX_IDENTITY = [\r\n\t\t'attribute vec2 vertex;',\r\n\t\t'varying vec2 texCoord;',\r\n\r\n\t\t'void main() {',\r\n\t\t\t'texCoord = vertex;',\r\n\t\t\t'gl_Position = vec4((vertex * 2.0 - 1.0) * vec2(1, -1), 0.0, 1.0);',\r\n\t\t'}'\r\n\t].join('\\n');\r\n\r\nvar MACROBLOCK_TYPE_TABLES = [\r\n\tnull,\r\n\tMACROBLOCK_TYPE_I,\r\n\tMACROBLOCK_TYPE_P,\r\n\tMACROBLOCK_TYPE_B\r\n];\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Bit Reader\r\n\r\nvar BitReader = function(arrayBuffer) {\r\n\tthis.bytes = new Uint8Array(arrayBuffer);\r\n\tthis.length = this.bytes.length;\r\n\tthis.writePos = this.bytes.length;\r\n\tthis.index = 0;\r\n};\r\n\r\nBitReader.NOT_FOUND = -1;\r\n\r\nBitReader.prototype.findNextMPEGStartCode = function() {\r\n\tfor (var i = (this.index+7 >> 3); i < this.writePos; i++) {\r\n\t\tif (\r\n\t\t\tthis.bytes[i] === 0x00 &&\r\n\t\t\tthis.bytes[i+1] === 0x00 &&\r\n\t\t\tthis.bytes[i+2] === 0x01\r\n\t\t) {\r\n\t\t\tthis.index = (i+4) << 3;\r\n\t\t\treturn this.bytes[i+3];\r\n\t\t}\r\n\t}\r\n\tthis.index = (this.writePos << 3);\r\n\treturn BitReader.NOT_FOUND;\r\n};\r\n\r\nBitReader.prototype.nextBytesAreStartCode = function() {\r\n\tvar i = (this.index+7 >> 3);\r\n\treturn (\r\n\t\ti >= this.writePos || (\r\n\t\t\tthis.bytes[i] === 0x00 &&\r\n\t\t\tthis.bytes[i+1] === 0x00 &&\r\n\t\t\tthis.bytes[i+2] === 0x01\r\n\t\t)\r\n\t);\r\n};\r\n\r\nBitReader.prototype.nextBits = function(count) {\r\n\tvar\r\n\t\tbyteOffset = this.index >> 3,\r\n\t\troom = (8 - this.index % 8);\r\n\r\n\tif (room >= count) {\r\n\t\treturn (this.bytes[byteOffset] >> (room - count)) & (0xff >> (8-count));\r\n\t}\r\n\r\n\tvar\r\n\t\tleftover = (this.index + count) % 8, // Leftover bits in last byte\r\n\t\tend = (this.index + count -1) >> 3,\r\n\t\tvalue = this.bytes[byteOffset] & (0xff >> (8-room)); // Fill out first byte\r\n\r\n\tfor (byteOffset++; byteOffset < end; byteOffset++) {\r\n\t\tvalue <<= 8; // Shift and\r\n\t\tvalue |= this.bytes[byteOffset]; // Put next byte\r\n\t}\r\n\r\n\tif (leftover > 0) {\r\n\t\tvalue <<= leftover; // Make room for remaining bits\r\n\t\tvalue |= (this.bytes[byteOffset] >> (8 - leftover));\r\n\t}\r\n\telse {\r\n\t\tvalue <<= 8;\r\n\t\tvalue |= this.bytes[byteOffset];\r\n\t}\r\n\r\n\treturn value;\r\n};\r\n\r\nBitReader.prototype.getBits = function(count) {\r\n\tvar value = this.nextBits(count);\r\n\tthis.index += count;\r\n\treturn value;\r\n};\r\n\r\nBitReader.prototype.advance = function(count) {\r\n\treturn (this.index += count);\r\n};\r\n\r\nBitReader.prototype.rewind = function(count) {\r\n\treturn (this.index -= count);\r\n};\r\n\r\n})(window);\r\n\n\n//# sourceURL=webpack://node_web/./src/client/js/jsmpeg.min.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/client/js/jsmpeg.min.js"]();
/******/ 	
/******/ })()
;